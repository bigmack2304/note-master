{"version":3,"file":"static/js/Dedicated Worker.f78dad5f.chunk.js","mappings":"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","sources":["0-shared/utils/classes/saveDataComponentTable.ts","0-shared/utils/classes/saveDataNode.ts","0-shared/utils/classes/saveDataTag.ts","0-shared/utils/idGenerator.ts","0-shared/utils/scopeChecks.ts","0-shared/utils/typeHelpers.ts","2-features/utils/appIndexedDBFynctions/appIndexedDBConst.ts","2-features/utils/appIndexedDBFynctions/appIndexedDBEvents.ts","2-features/utils/appIndexedDBFynctions/dataTreeDb.ts","2-features/utils/appIndexedDBFynctions/globalTagsFunctions.ts","2-features/utils/appIndexedDBFynctions/imageFunctions.ts","../node_modules/idb/build/index.js","2-features/utils/appIndexedDBFynctions/openDB.ts","2-features/utils/appIndexedDBFynctions/tableFunctions.ts","2-features/utils/saveDataParse.ts","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","2-features/utils/saveDataEditFunctions/deleteById.ts","2-features/utils/saveDataUtilsFunctions/getAllIdsInNode.ts","2-features/utils/saveDataParseFunctions/getNodeById.ts","0-shared/utils/note_find.ts","2-features/utils/saveDataParseFunctions/getParentNode.ts","0-shared/utils/classes/saveDataComponentHeader.ts","0-shared/utils/classes/saveDataComponentText.ts","0-shared/utils/classes/saveDataComponentCode.ts","0-shared/utils/classes/saveDataComponentImage.ts","0-shared/utils/classes/saveDataComponentLink.ts","0-shared/utils/classes/saveDataComponentVideo.ts","0-shared/utils/classes/saveDataComponentList.ts","0-shared/dedicatedWorker/dedicatedWorker.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentImageSettings.ts","2-features/utils/saveDataEditFunctions/deleteComponentInNote.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentLinkSettings.ts","2-features/utils/saveDataEditFunctions/updateNoteImage.ts","2-features/utils/saveDataEditFunctions/updateNodeLink.ts","2-features/utils/saveDataEditFunctions/updateNodeTable.ts","2-features/utils/saveDataEditFunctions/updateNodeTableSettings.ts","2-features/utils/saveDataEditFunctions/updateNoteValue.ts","2-features/utils/saveDataEditFunctions/updNoteComponentsOrder.ts","0-shared/utils/arrayFunctions.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentTextSettings.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentListSettings.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentHeaderSettings.ts","2-features/utils/saveDataEditFunctions/componentCodeSettings.ts","2-features/utils/saveDataEditFunctions/updateNodeCompleted.ts","2-features/utils/saveDataEditFunctions/updateNodeName.ts","2-features/utils/saveDataEditFunctions/addNodeTo.ts","2-features/utils/saveDataEditFunctions/nodeMuveTo.ts","2-features/utils/saveDataEditFunctions/noteDeleteTag.ts","2-features/utils/saveDataEditFunctions/noteAddTag.ts","2-features/utils/saveDataEditFunctions/projectDeleteTag.ts","2-features/utils/saveDataEditFunctions/projectEditeTag.ts","2-features/utils/saveDataEditFunctions/addNewComponentToNote.ts"],"sourcesContent":["import { DataNode } from \"./saveDataNode\";\nimport { IdGenerator } from \"../idGenerator\";\nimport type { TBodyComponentTable, TTableValue } from \"0-shared/types/dataSave\";\n\n/**\n *  значение пустой таблицы. (для db и компонента таблицы)\n */\nconst tableValue_preset_default: TTableValue = {\n    headers: [],\n    rows: [],\n};\n\n/**\n *  значение пустой таблицы. (для db и компонента таблицы)\n */\nconst TableValue_preset_2x1: TTableValue = {\n    headers: [\n        { colIndex: 0, value: \"\" },\n        { colIndex: 1, value: \"\" },\n    ],\n    rows: [\n        {\n            rowIndex: 0,\n            value: [\n                { colIndex: 0, value: \"\" },\n                { colIndex: 1, value: \"\" },\n            ],\n        },\n    ],\n};\n\n/**\n *  класс для создания новых компонентов таблицы заметки\n */\nclass saveDataComponentTable extends DataNode implements TBodyComponentTable {\n    public component: TBodyComponentTable[\"component\"];\n    public value: TBodyComponentTable[\"value\"];\n    public desc: TBodyComponentTable[\"desc\"];\n    public viewButtons: TBodyComponentTable[\"viewButtons\"];\n    public backlight: TBodyComponentTable[\"backlight\"];\n    public aligin: TBodyComponentTable[\"aligin\"];\n\n    constructor(idGenerator: InstanceType<typeof IdGenerator>) {\n        super(\"component\", idGenerator);\n\n        this.component = \"table\";\n        this.value = \"\";\n        this.desc = \"\";\n        this.backlight = true;\n        this.viewButtons = false;\n        this.aligin = \"left\";\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { saveDataComponentTable, tableValue_preset_default, TableValue_preset_2x1 };\n","import { savedIdGenerator } from \"0-shared/utils/idGenerator\";\nimport { IdGenerator } from \"0-shared/utils/idGenerator\";\nimport type { IDataTreeNode, TNodeType } from \"0-shared/types/dataSave\";\n\n/**\n *\n *  базовый класс для создания новых нод в дереве IDataTreeRootFolder\n */\nclass DataNode implements IDataTreeNode {\n    public id: string;\n    public type: TNodeType;\n\n    constructor(type: TNodeType, idGenerator?: InstanceType<typeof IdGenerator>) {\n        const insIdGenerator = !idGenerator ? savedIdGenerator.instatnceIdGenerator : idGenerator;\n        if (!insIdGenerator) throw new Error(\"IdGenerator is not defined\");\n\n        this.id = insIdGenerator.generateId();\n        this.type = type;\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { DataNode };\n","import type { IGlobalTag, TTagColors } from \"0-shared/types/dataSave\";\n\n/**\n *  класс для создания новых тегов для IAllTags\n */\nclass DataTag implements IGlobalTag {\n    public tag_name: IGlobalTag[\"tag_name\"];\n    public color: IGlobalTag[\"color\"];\n\n    constructor(name: string, color: TTagColors) {\n        this.tag_name = name;\n        this.color = color;\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { DataTag };\n","import { isDWorkerScope } from \"./scopeChecks\";\n\n// генератор ID в виде строки из 16 символов\n\n/**\n * класс для генерации уникальных ID, используется для генерации уникальных идентификаторов для DataTemp в indexed db\n * @constructor_Param cache - Set(string) обьект с данными который будет использоватся в качестве кеша со всеми id\n */\nclass IdGenerator {\n    static _charMap: string = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n    private _cache: Set<string> = new Set();\n\n    constructor(cache: Set<string>) {\n        this._cache = cache;\n    }\n\n    public generateId(): string {\n        const generator = () => {\n            let result = \"\";\n            for (let i = 0; i < 16; i++) {\n                result += IdGenerator._charMap.charAt(Math.floor(Math.random() * IdGenerator._charMap.length));\n            }\n            return result;\n        };\n\n        let newId: string;\n\n        do {\n            newId = generator();\n        } while (this._cache.has(newId));\n\n        this._cache.add(newId);\n        //console.log(this.getIdsArray());\n        console.log(`idGenerator: add -> ${newId}`);\n        return newId;\n    }\n\n    public deleteId(id: string) {\n        if (this._cache.has(id)) {\n            this._cache.delete(id);\n            //console.log(this.getIdsArray());\n            console.log(`idGenerator: delete -> ${id}`);\n        }\n    }\n\n    public getIdsArray() {\n        return Array.from(this._cache);\n    }\n}\n\ntype TSavedIdGenerator = {\n    instatnceIdGenerator: IdGenerator | undefined;\n};\n\n/**\n * эту конструкцию будем использовать для сохранения экземпляра класса IdGenerator\n * и передачи ее в разные участки кода\n * @ изменение своиства instatnceIdGenerator будет приводить к событию appIdGeneratorNewInstance на window\n */\nconst savedIdGenerator: TSavedIdGenerator = new Proxy(\n    {\n        instatnceIdGenerator: undefined,\n    },\n    {\n        set(target, prop, newValue, receiver) {\n            if (isDWorkerScope()) {\n                console.error(\"set savedIdGenerator.instatnceIdGenerator can not be used in worker scope\");\n                throw new Error(\"set savedIdGenerator.instatnceIdGenerator can not be used in worker scope\");\n            }\n            if (prop === \"instatnceIdGenerator\") {\n                window.dispatchEvent(new CustomEvent(\"appIdGeneratorNewInstance\"));\n                console.group(\"savedIdGenerator: updated\");\n                console.log(newValue);\n                console.groupEnd();\n            }\n            return Reflect.set(target, prop, newValue, receiver);\n        },\n    }\n);\n\nexport { savedIdGenerator, IdGenerator };\nexport type { TSavedIdGenerator };\n","/**\n * Проверка на отсутствие глобольногоо обьекта window\n */\nfunction isNotWindow() {\n    return typeof window === \"undefined\";\n}\n\n/**\n * проверка что окружение self есть и оно пренадлежить Dedicated Worker\n */\nfunction isDWorkerScope() {\n    //eslint-disable-next-line\n    return typeof self === \"object\" && self.toString() === \"[object DedicatedWorkerGlobalScope]\";\n}\n\nexport { isNotWindow, isDWorkerScope };\n","import { ForwardRefRenderFunction } from \"react\";\nimport type { IDataTreeNote, IDataTreeFolder, TNoteBody, IDataSave, IGlobalTag } from \"0-shared/types/dataSave\";\nimport type {\n    TMessageDataType,\n    TMessageDelById,\n    TMessageDelCompInNote,\n    TMessageCloneFiltredTreeOnWorker,\n    TMessageUpdateNodeValueOnWorker,\n    TMessageUpdNoteComponentsOrderOnWorker,\n    TMessageUpdateNodeImageOnWorker,\n    TMessageUpdateNodeTableOnWorker,\n    TMessageUpdateNodeTableSettingsOnWorker,\n    TMessageUpdateNodeLinkOnWorker,\n    TMessageGetNodeByIdOnWorker,\n    TMessageUpdateNoteComponentLinkSettingsOnWorker,\n    TMessageUpdateNoteComponentImageSettingsOnWorker,\n    TMessageUpdateNoteComponentTextSettingsOnWorker,\n    TMessageUpdateNoteComponentListSettingsOnWorker,\n    TMessageUpdateNoteComponentHeaderSettingsOnWorker,\n    TMessageUpdateNoteComponentCodeSettingsOnWorker,\n    TMessageUpdateNodeCompletedOnWorker,\n    TMessageUpdateNodeNameOnWorker,\n    TMessageAddNodeToOnWorker,\n    TMessageNodeMuveToOnWorker,\n    TMessageNoteDeleteTagOnWorker,\n    TMessageNoteAddTagOnWorker,\n    TMessageProjectDeleteTagOnWorker,\n    TMessageGetParentNodeOnWorker,\n    TMessageProjectEditeTagOnWorker,\n    TMessageAddNewComponentToNoteOnWorker,\n} from \"0-shared/dedicatedWorker/workerTypes\";\nimport type { TTableValue } from \"0-shared/types/dataSave\";\n\n/**\n *  убирает своиство readonly у полей массива или обьекта\n */\ntype RemoveReadonly<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n/**\n * вычисляет пропсы компонента\n * @tparam T - тип компонента\n */\ntype GetProps<T> = T extends React.ComponentType<infer Props> ? Props : unknown;\n\n/**\n * типизирует параметр ref в компоненте, если используется forwardRef\n * @tparam T - тип элемента на который перенаправляется ref (например HTMLInputElement)\n */\ntype Ref<T> = Parameters<ForwardRefRenderFunction<T>>[1];\n\n/**\n * преобразует массив от Parameters<> в обьект, где, K будет массивом ключей\n * @tparam T - массив возвращенный дженериком Parameters\n * @tparam K - массив ключей, которые будут присвоины типам с соответствующими индексами в T\n */\ntype TupleToObject<T extends any[], K extends { [I in keyof T]: PropertyKey }> = {\n    [I in keyof T as I extends keyof any[] ? never : K[I]]: T[I];\n};\n\nfunction isTGlobalTag(value: any): value is IGlobalTag {\n    if (typeof value !== \"object\") return false;\n    if (!(\"tag_name\" in value) || (\"tag_name\" in value && typeof value.tag_name !== \"string\")) return false;\n    if (!(\"color\" in value) || (\"color\" in value && typeof value.color !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу IDataTreeNote\n * @param node\n * @returns boolean\n */\nfunction isDataTreeNote(node: any): node is IDataTreeNote {\n    if (typeof node !== \"object\") return false;\n    if (!(\"type\" in node)) return false;\n    return node.type === \"note\";\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу IDataTreeFolder\n * @param node\n * @returns boolean\n */\nfunction isDataTreeFolder(node: any): node is IDataTreeFolder {\n    if (typeof node !== \"object\") return false;\n    if (!(\"type\" in node)) return false;\n    return node.type === \"folder\";\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TTableValue\n * @returns boolean\n */\nfunction isTableValue(value: any): value is TTableValue {\n    if (typeof value !== \"object\") return false;\n    if (!(\"headers\" in value) || (\"headers\" in value && !Array.isArray(value.headers))) return false;\n    if (!(\"rows\" in value) || (\"rows\" in value && !Array.isArray(value.rows))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TNoteBody\n * @param node\n * @returns boolean\n */\nfunction isDataNoteBody(node: any): node is TNoteBody {\n    if (typeof node !== \"object\") return false;\n    if (!(\"type\" in node)) return false;\n    return node.type === \"component\";\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу IDataSave\n * @param node\n * @returns boolean\n */\nfunction isDataSave(node: any): node is IDataSave {\n    if (typeof node !== \"object\") return false;\n    if (!(\"db_type\" in node)) return false;\n    if (!(\"data_tree\" in node)) return false;\n    if (!(\"global_tags\" in node)) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageDataType dedicated воркера\n */\nfunction isFunctionData(value: any): value is TMessageDataType {\n    if (typeof value !== \"object\") return false;\n    if (!(\"argument_names\" in value)) return false;\n    if (!(\"argument_values\" in value)) return false;\n    if (!(\"func_data\" in value)) return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"function executor\")) return false;\n    if (!Array.isArray(value.argument_names)) return false;\n    if (!Array.isArray(value.argument_values)) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageDelById dedicated воркера\n */\nfunction isDelByIdData(value: any): value is TMessageDelById {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"delete by id\")) return false;\n    if (!(\"rootNode\" in value) || (\"rootNode\" in value && !isDataTreeFolder(value.rootNode))) return false;\n    if (!(\"target_id\" in value) || (\"target_id\" in value && typeof value.target_id !== \"string\")) return false;\n    if (!(\"savedIdGenerator\" in value) || (\"savedIdGenerator\" in value && !Array.isArray(value.savedIdGenerator))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageDelCompInNote dedicated воркера\n */\nfunction isDelCompInNote(value: any): value is TMessageDelCompInNote {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"delete component in note\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"componentID\" in value) || (\"componentID\" in value && typeof value.componentID !== \"string\")) return false;\n    if (!(\"savedIdGenerator\" in value) || (\"savedIdGenerator\" in value && !Array.isArray(value.savedIdGenerator))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageDelCompInNote dedicated воркера\n */\nfunction isCloneFiltredTree(value: any): value is TMessageCloneFiltredTreeOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"clone filtred tree\")) return false;\n    if (!(\"orig_obj\" in value) || (\"orig_obj\" in value && !isDataTreeFolder(value.orig_obj))) return false;\n    if (!(\"filtres\" in value)) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeValueOnWorker dedicated воркера\n */\nfunction isUpdateNodeValue(value: any): value is TMessageUpdateNodeValueOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node value\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"newValue\" in value) || (\"newValue\" in value && typeof value.newValue !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdNoteComponentsOrderOnWorker dedicated воркера\n */\nfunction isUpdNoteComponentsOrder(value: any): value is TMessageUpdNoteComponentsOrderOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note components order\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentDragId\" in value) || (\"componentDragId\" in value && typeof value.componentDragId !== \"string\")) return false;\n    if (!(\"toComponentDragId\" in value) || (\"toComponentDragId\" in value && typeof value.toComponentDragId !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdNoteComponentsOrderOnWorker dedicated воркера\n */\nfunction isUpdateNodeImage(value: any): value is TMessageUpdateNodeImageOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node image\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"newName\" in value) || (\"newName\" in value && typeof value.newName !== \"string\")) return false;\n    if (!(\"newSrc\" in value) || (\"newSrc\" in value && typeof value.newSrc !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeTableOnWorker dedicated воркера\n */\nfunction isUpdateNodeTable(value: any): value is TMessageUpdateNodeTableOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node table\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"newValue\" in value) || (\"newValue\" in value && !isTableValue(value.newValue))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeTableSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNodeTableSettings(value: any): value is TMessageUpdateNodeTableSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node table settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"backlight\" in value) || (\"backlight\" in value && typeof value.backlight !== \"boolean\")) return false;\n    if (!(\"desc\" in value) || (\"desc\" in value && typeof value.desc !== \"string\")) return false;\n    if (!(\"viewButtons\" in value) || (\"viewButtons\" in value && typeof value.viewButtons !== \"boolean\")) return false;\n    if (!(\"aligin\" in value) || (\"aligin\" in value && typeof value.aligin !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeLinkOnWorker dedicated воркера\n */\nfunction isUpdateNodeLink(value: any): value is TMessageUpdateNodeLinkOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node link\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"target\" in value) || (\"target\" in value && typeof value.target !== \"string\")) return false;\n    if (!(\"value\" in value) || (\"value\" in value && typeof value.value !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageGetNodeByIdOnWorker dedicated воркера\n */\nfunction isGetNodeById(value: any): value is TMessageGetNodeByIdOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"get node by id\")) return false;\n    if (!(\"args\" in value) || (\"args\" in value && !Array.isArray(value.args))) return false;\n    if (value.args.length < 2) return false;\n    if (!isDataTreeFolder(value.args[0])) return false;\n    if (typeof value.args[1] !== \"string\") return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentLinkSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentLinkSettings(value: any): value is TMessageUpdateNoteComponentLinkSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update Note component link settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"isLabel\" in value) || (\"isLabel\" in value && typeof value.isLabel !== \"boolean\")) return false;\n    if (!(\"isBg\" in value) || (\"isBg\" in value && typeof value.isBg !== \"boolean\")) return false;\n    if (!(\"labelVal\" in value) || (\"labelVal\" in value && typeof value.labelVal !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentImageSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentImageSettings(value: any): value is TMessageUpdateNoteComponentImageSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component image settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"imageDesc\" in value) || (\"imageDesc\" in value && typeof value.imageDesc !== \"string\")) return false;\n    if (!(\"isDescHidden\" in value) || (\"isDescHidden\" in value && typeof value.isDescHidden !== \"boolean\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentTextSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentTextSettings(value: any): value is TMessageUpdateNoteComponentTextSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component text settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"textBackground\" in value) || (\"textBackground\" in value && typeof value.textBackground !== \"boolean\")) return false;\n    if (!(\"textFormat\" in value) || (\"textFormat\" in value && typeof value.textFormat !== \"boolean\")) return false;\n    if (!(\"fontValue\" in value) || (\"fontValue\" in value && typeof value.fontValue !== \"string\")) return false;\n    if (!(\"lineBreak\" in value) || (\"lineBreak\" in value && typeof value.lineBreak !== \"boolean\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentListSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentListSettings(value: any): value is TMessageUpdateNoteComponentListSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component list settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"listBg\" in value) || (\"listBg\" in value && typeof value.listBg !== \"boolean\")) return false;\n    if (!(\"isNumeric\" in value) || (\"isNumeric\" in value && typeof value.isNumeric !== \"boolean\")) return false;\n    if (!(\"aligin\" in value) || (\"aligin\" in value && typeof value.aligin !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentHeaderSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentHeaderSettings(value: any): value is TMessageUpdateNoteComponentHeaderSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component header settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"textAligin\" in value) || (\"textAligin\" in value && typeof value.textAligin !== \"string\")) return false;\n    if (!(\"headerSize\" in value) || (\"headerSize\" in value && typeof value.headerSize !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentCodeSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentCodeSettings(value: any): value is TMessageUpdateNoteComponentCodeSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component code settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"codeTheme\" in value) || (\"codeTheme\" in value && typeof value.codeTheme !== \"string\")) return false;\n    if (!(\"codeLanguage\" in value) || (\"codeLanguage\" in value && typeof value.codeLanguage !== \"string\")) return false;\n    if (!(\"isExpand\" in value) || (\"isExpand\" in value && typeof value.isExpand !== \"boolean\")) return false;\n    if (!(\"expandDesc\" in value) || (\"expandDesc\" in value && typeof value.expandDesc !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeCompletedOnWorker dedicated воркера\n */\nfunction isUpdateNodeCompleted(value: any): value is TMessageUpdateNodeCompletedOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node completed\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"newValue\" in value) || (\"newValue\" in value && typeof value.newValue !== \"boolean\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeNameOnWorker dedicated воркера\n */\nfunction isUpdateNodeName(value: any): value is TMessageUpdateNodeNameOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node name\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"target_id\" in value) || (\"target_id\" in value && typeof value.target_id !== \"string\")) return false;\n    if (!(\"newName\" in value) || (\"newName\" in value && typeof value.newName !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageAddNodeToOnWorker dedicated воркера\n */\nfunction isAddNodeTo(value: any): value is TMessageAddNodeToOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"add node to\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"insertToId\" in value) || (\"insertToId\" in value && typeof value.insertToId !== \"string\")) return false;\n    if (!(\"newNode\" in value)) return false;\n    if (\"newNode\" in value) {\n        if (!isDataTreeNote(value.newNode) && !isDataTreeFolder(value.newNode) && !isDataNoteBody(value.newNode)) return false;\n    }\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageNodeMuveToOnWorker dedicated воркера\n */\nfunction isNodeMuveTo(value: any): value is TMessageNodeMuveToOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"node move to\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"muvedNodeID\" in value) || (\"muvedNodeID\" in value && typeof value.muvedNodeID !== \"string\")) return false;\n    if (!(\"muveToID\" in value) || (\"muveToID\" in value && typeof value.muveToID !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageNoteDeleteTagOnWorker dedicated воркера\n */\nfunction isNoteDeleteTag(value: any): value is TMessageNoteDeleteTagOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"note delete tag\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"targetNoteID\" in value) || (\"targetNoteID\" in value && typeof value.targetNoteID !== \"string\")) return false;\n    if (!(\"tag\" in value) || (\"tag\" in value && !isTGlobalTag(value.tag))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageNoteAddTagOnWorker dedicated воркера\n */\nfunction isNoteAddTag(value: any): value is TMessageNoteAddTagOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"note add tag\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"targetNoteID\" in value) || (\"targetNoteID\" in value && typeof value.targetNoteID !== \"string\")) return false;\n    if (!(\"tag\" in value) || (\"tag\" in value && !(typeof value.tag === \"string\" || Array.isArray(value.tag)))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageProjectDeleteTagOnWorker dedicated воркера\n */\nfunction isProjectDeleteTag(value: any): value is TMessageProjectDeleteTagOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"project delete tag\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"tagName\" in value) || (\"tagName\" in value && typeof value.tagName !== \"string\")) return false;\n    if (!(\"tagData\" in value) || (\"tagData\" in value && !(typeof value.tagData === \"object\"))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageGetParentNodeOnWorker dedicated воркера\n */\nfunction isGetParentNode(value: any): value is TMessageGetParentNodeOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"get parent node\")) return false;\n    if (!(\"args\" in value) || (\"args\" in value && !Array.isArray(value.args))) return false;\n    if (value.args.length < 2) return false;\n    if (!isDataTreeFolder(value.args[0])) return false;\n    if (typeof value.args[1] !== \"string\") return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageProjectEditeTagOnWorker dedicated воркера\n */\nfunction isProjectEditeTag(value: any): value is TMessageProjectEditeTagOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"project edite tag\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"tagData\" in value) || (\"tagData\" in value && !(typeof value.tagData === \"object\"))) return false;\n    if (!(\"oldTagName\" in value) || (\"oldTagName\" in value && typeof value.oldTagName !== \"string\")) return false;\n    if (!(\"newTagName\" in value) || (\"newTagName\" in value && typeof value.newTagName !== \"string\")) return false;\n    if (!(\"newTagColor\" in value) || (\"newTagColor\" in value && typeof value.newTagColor !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageAddNewComponentToNoteOnWorker dedicated воркера\n */\nfunction isAddNewComponentToNote(value: any): value is TMessageAddNewComponentToNoteOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"add new component to note\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentType\" in value) || (\"componentType\" in value && typeof value.componentType !== \"string\")) return false;\n    if (!(\"savedIdGenerator\" in value) || (\"savedIdGenerator\" in value && !Array.isArray(value.savedIdGenerator))) return false;\n    return true;\n}\n\nexport {\n    isDataTreeNote,\n    isDataTreeFolder,\n    isDataNoteBody,\n    isDataSave,\n    isFunctionData,\n    isDelByIdData,\n    isDelCompInNote,\n    isCloneFiltredTree,\n    isUpdateNodeValue,\n    isUpdNoteComponentsOrder,\n    isUpdateNodeImage,\n    isTableValue,\n    isUpdateNodeTable,\n    isUpdateNodeTableSettings,\n    isUpdateNodeLink,\n    isGetNodeById,\n    isUpdateNoteComponentLinkSettings,\n    isUpdateNoteComponentImageSettings,\n    isUpdateNoteComponentTextSettings,\n    isUpdateNoteComponentListSettings,\n    isUpdateNoteComponentHeaderSettings,\n    isUpdateNoteComponentCodeSettings,\n    isUpdateNodeCompleted,\n    isUpdateNodeName,\n    isAddNodeTo,\n    isNodeMuveTo,\n    isTGlobalTag,\n    isNoteDeleteTag,\n    isNoteAddTag,\n    isProjectDeleteTag,\n    isGetParentNode,\n    isProjectEditeTag,\n    isAddNewComponentToNote,\n};\nexport type { GetProps, Ref, RemoveReadonly, TupleToObject };\n","/**\n * различные константы и дефолтные значения как либо связанные с indexed db\n */\n\n/**\n * ключи хранилищь в indexed db, в которых могт лежать данные приложения заметок\n */\nconst tempStoreData = [\"db_type\", \"data_tree\", \"global_tags\", \"data_images\", \"data_tables\"] as const;\n\nconst DB_NAME = \"app_note_master_db_data\";\nconst DB_VERSION = 3;\nconst TEMP_DATA_KEY = \"0\";\n\nfunction def_onError(e: Event) {\n    console.warn(e);\n}\n\nfunction def_onComplete(e: Event) {\n    //    console.log(e);\n}\n\nexport { tempStoreData, DB_NAME, DB_VERSION, TEMP_DATA_KEY, def_onError, def_onComplete };\n","import { isDWorkerScope } from \"0-shared/utils/scopeChecks\";\n\n/**\n * генерация событий на обьекте window при изменениях в indexed db (myDB)\n */\n\nfunction dispatchEventIndexedDBTreeUpdate() {\n    if (!isDWorkerScope()) {\n        window.dispatchEvent(new CustomEvent(\"appIndexedDBTreeUpdate\"));\n    } else {\n        //eslint-disable-next-line\n        self.postMessage(\"worker generate event: appIndexedDBTreeUpdate\");\n    }\n}\n\nfunction dispatchEventIndexedDBTagsUpdate() {\n    if (!isDWorkerScope()) {\n        window.dispatchEvent(new CustomEvent(\"appIndexedDBTagsUpdate\"));\n    } else {\n        //eslint-disable-next-line\n        self.postMessage(\"worker generate event: appIndexedDBTagsUpdate\");\n    }\n}\n\nfunction dispatchEventIndexedDBImagesUpdate() {\n    if (!isDWorkerScope()) {\n        window.dispatchEvent(new CustomEvent(\"appIndexedDBImagesUpdate\"));\n    } else {\n        //eslint-disable-next-line\n        self.postMessage(\"worker generate event: appIndexedDBImagesUpdate\");\n    }\n}\n\nfunction dispatchEventIndexedDBTableUpdate() {\n    if (!isDWorkerScope()) {\n        window.dispatchEvent(new CustomEvent(\"appIndexedDBTablesUpdate\"));\n    } else {\n        //eslint-disable-next-line\n        self.postMessage(\"worker generate event: appIndexedDBTablesUpdate\");\n    }\n}\n\nexport {\n    dispatchEventIndexedDBTreeUpdate,\n    dispatchEventIndexedDBTagsUpdate,\n    dispatchEventIndexedDBImagesUpdate,\n    dispatchEventIndexedDBTableUpdate,\n};\n","import { def_onComplete, def_onError, TEMP_DATA_KEY } from \"./appIndexedDBConst\";\nimport { openIndexedDB } from \"./openDB\";\nimport { dispatchEventIndexedDBTreeUpdate } from \"./appIndexedDBEvents\";\nimport type { MyDB, TSetDataEntity, TGetDataEntity } from \"./appIndexedDBTypes\";\n\n/**\n * Записывает новое значение вместо обьекта data_tree в indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(value): вызывается после применения изменений\n * @property value: новое значение\n */\nasync function setDataTreeDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    value,\n}: TSetDataEntity<MyDB[\"data_tree\"][\"value\"]>) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tree\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    tx.store.put(value, TEMP_DATA_KEY);\n    await tx.done;\n    callback && callback(value);\n    dispatchEventIndexedDBTreeUpdate();\n    return value;\n}\n\n/**\n * возвращает обьект data_tree из indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(data_tree | undefined): вызывается после поиска\n * @returns Promise<data_tree | undefined>\n */\nasync function getDataTreeDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n}: TGetDataEntity<MyDB[\"data_tree\"][\"value\"] | undefined> = {}) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tree\", \"readonly\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    let value = await tx.store.get(TEMP_DATA_KEY);\n    await tx.done;\n    callback && callback(value);\n    return value;\n}\n\nexport { getDataTreeDB, setDataTreeDB };\n","import { def_onComplete, def_onError, TEMP_DATA_KEY } from \"./appIndexedDBConst\";\nimport { openIndexedDB } from \"./openDB\";\nimport { dispatchEventIndexedDBTagsUpdate } from \"./appIndexedDBEvents\";\nimport type { MyDB, TSetDataEntity, TGetDataEntity } from \"./appIndexedDBTypes\";\n\n/**\n * Записывает новое значение вместо обьекта global_tags в indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(value): вызывается после применения изменений\n * @property value: новое значение\n */\nasync function setGlobalTagsDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    value,\n}: TSetDataEntity<MyDB[\"global_tags\"][\"value\"]>) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"global_tags\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    tx.store.put(value, TEMP_DATA_KEY);\n    await tx.done;\n    callback && callback(value);\n    dispatchEventIndexedDBTagsUpdate();\n    return value;\n}\n\n/**\n * возвращает обьект global_tags из indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @returns Promise<global_tags | undefined>\n */\nasync function getGlobalTagsDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n}: TGetDataEntity<MyDB[\"global_tags\"][\"value\"] | undefined> = {}) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"global_tags\", \"readonly\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    let value = await tx.store.get(TEMP_DATA_KEY);\n    await tx.done;\n    callback && callback(value);\n    return value;\n}\n\nexport { setGlobalTagsDB, getGlobalTagsDB };\n","import { def_onComplete, def_onError } from \"./appIndexedDBConst\";\nimport { dispatchEventIndexedDBImagesUpdate } from \"./appIndexedDBEvents\";\nimport { openIndexedDB } from \"./openDB\";\nimport type { TGetKeyDataEntity, MyDB, TSetKeyDataEntity } from \"./appIndexedDBTypes\";\n\n/**\n * удаляет элемент из data_images по ключу, или много элементов по массиву ключей\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @property key: ключь (ID) элемента который нужно получить\n * @returns Promise<global_tags | undefined>\n */\nasync function delImageDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    key,\n}: TGetKeyDataEntity<boolean | undefined, string | string[]>) {\n    if (!key) throw new Error(\"the key is required\");\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_images\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    if (Array.isArray(key)) {\n        for await (let keyItem of key) {\n            tx.store.delete(keyItem);\n        }\n    } else {\n        await tx.store.delete(key);\n    }\n    await tx.done;\n    callback && callback(true);\n    dispatchEventIndexedDBImagesUpdate();\n    return true;\n}\n\n/**\n * Записывает новое значение в хранилище data_images в indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(value): вызывается после применения изменений\n * @property value: новое значение\n */\nasync function setImageDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    value,\n    key,\n}: TSetKeyDataEntity<MyDB[\"data_images\"][\"value\"]>) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_images\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n\n    const hasItemInDB = await tx.store.getKey(key);\n    if (hasItemInDB) {\n        await tx.store.delete(key);\n    }\n\n    await tx.store.add(value);\n    await tx.done;\n    callback && callback(value);\n    dispatchEventIndexedDBImagesUpdate();\n    return value;\n}\n\n/**\n * возвращает элемент из data_images из indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @property key: ключь (ID) элемента который нужно получить\n * @returns Promise<global_tags | undefined>\n */\nasync function getImageDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    key,\n}: TGetKeyDataEntity<MyDB[\"data_images\"][\"value\"] | undefined>) {\n    if (!key) throw new Error(\"key \");\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_images\", \"readonly\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    let value = await tx.store.get(key);\n    await tx.done;\n    callback && callback(value);\n    return value;\n}\n\nexport { delImageDB, getImageDB, setImageDB };\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","import { openDB } from \"idb\";\nimport { DB_NAME, DB_VERSION } from \"./appIndexedDBConst\";\nimport type { MyDB } from \"./appIndexedDBTypes\";\n\n/**\n * async функция, возвращает обьект indexed db\n * @returns\n */\nasync function openIndexedDB() {\n    const db = await openDB<MyDB>(DB_NAME, DB_VERSION, {\n        upgrade(db, oldVersion, newVersion, transaction, event) {\n            if (oldVersion === newVersion) {\n                const savedDataDB = db.createObjectStore(\"savedData\");\n                const dbType = db.createObjectStore(\"db_type\");\n                const data_tree = db.createObjectStore(\"data_tree\");\n                const global_tags = db.createObjectStore(\"global_tags\");\n                const data_images = db.createObjectStore(\"data_images\", {\n                    keyPath: \"id\",\n                });\n                const data_tables = db.createObjectStore(\"data_tables\", {\n                    keyPath: \"id\",\n                });\n            } else {\n                //TODO: при изменении схемы бд, нужно менять версию бд, после чего нежно тут реализовать обновление схемы бд, для новой версии.\n                let currentVersion = oldVersion;\n                debugger;\n                do {\n                    switch (currentVersion + 1) {\n                        case 1:\n                            const savedDataDB = db.createObjectStore(\"savedData\");\n                            const dbType = db.createObjectStore(\"db_type\");\n                            const data_tree = db.createObjectStore(\"data_tree\");\n                            const global_tags = db.createObjectStore(\"global_tags\");\n                            break;\n                        case 2:\n                            const data_images = db.createObjectStore(\"data_images\", {\n                                keyPath: \"id\",\n                            });\n                            break;\n                        case 3:\n                            const data_tables = db.createObjectStore(\"data_tables\", {\n                                keyPath: \"id\",\n                            });\n                            break;\n                        default:\n                            throw new Error(\n                                \"A new version of the database has been detected, but the logic for updating the schema has not been implemented.\"\n                            );\n                    }\n                    currentVersion++;\n                } while (currentVersion < (newVersion ?? 1));\n            }\n        },\n        blocked(currentVersion, blockedVersion, event) {},\n        blocking(currentVersion, blockedVersion, event) {},\n        terminated() {},\n    });\n\n    return db;\n}\n\nexport { openIndexedDB };\n","import { def_onComplete, def_onError } from \"./appIndexedDBConst\";\nimport { dispatchEventIndexedDBTableUpdate } from \"./appIndexedDBEvents\";\nimport { openIndexedDB } from \"./openDB\";\nimport type { MyDB, TSetKeyDataEntity, TGetKeyDataEntity } from \"./appIndexedDBTypes\";\n\n/**\n * Записывает новое значение в хранилище data_table в indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(value): вызывается после применения изменений\n * @property value: новое значение\n */\nasync function setTableDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    value,\n    key,\n}: TSetKeyDataEntity<MyDB[\"data_tables\"][\"value\"]>) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tables\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n\n    const hasItemInDB = await tx.store.getKey(key);\n    if (hasItemInDB) {\n        await tx.store.delete(key);\n    }\n\n    await tx.store.add(value);\n    await tx.done;\n    callback && callback(value);\n    dispatchEventIndexedDBTableUpdate();\n    return value;\n}\n\n/**\n * возвращает элемент из data_table из indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @property key: ключь (ID) элемента который нужно получить\n * @returns Promise<global_tags | undefined>\n */\nasync function getTableDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    key,\n}: TGetKeyDataEntity<MyDB[\"data_tables\"][\"value\"] | undefined>) {\n    if (!key) throw new Error(\"key \");\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tables\", \"readonly\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    let value = await tx.store.get(key);\n    await tx.done;\n    callback && callback(value);\n    return value;\n}\n\n/**\n * удаляет элемент из data_table по ключу, или много элементов по массиву ключей\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @property key: ключь (ID) элемента который нужно получить\n * @returns Promise<global_tags | undefined>\n */\nasync function delTableDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    key,\n}: TGetKeyDataEntity<boolean | undefined, string | string[]>) {\n    if (!key) throw new Error(\"the key is required\");\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tables\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    if (Array.isArray(key)) {\n        for await (let keyItem of key) {\n            tx.store.delete(keyItem);\n        }\n    } else {\n        await tx.store.delete(key);\n    }\n    await tx.done;\n    callback && callback(true);\n    dispatchEventIndexedDBTableUpdate();\n    return true;\n}\n\nexport { delTableDB, setTableDB, getTableDB };\n","import { isDataTreeFolder, isDataTreeNote, isDataSave } from \"0-shared/utils/typeHelpers\";\nimport { nodeWithoutChildren } from \"./saveDataUtils\";\nimport type { IDataTreeFolder, IDataTreeNote, TNoteBody, IDataTreeRootFolder, IDataSave } from \"0-shared/types/dataSave\";\n\n// функции для поиска разлиных элементов в tempData в indexedDB\n\n/**\n * сбор всех ID из IDataTreeRootFolder\n * @param data обьект сохранения IDataTreeRootFolder\n * @returns\n */\nfunction getAllIds(data: IDataTreeRootFolder | IDataSave) {\n    const allIds = new Set<string>();\n\n    const parser = (node: IDataTreeFolder | IDataTreeNote | TNoteBody) => {\n        if (allIds.has(node.id)) throw new Error(\"Duplicate id in tempData\");\n        allIds.add(node.id);\n\n        if (isDataTreeFolder(node) && node.children) {\n            for (let item of node.children) {\n                parser(item);\n            }\n        }\n\n        if (isDataTreeNote(node)) {\n            for (let item of node.body) {\n                parser(item);\n            }\n        }\n    };\n\n    parser(isDataSave(data) ? data.data_tree : data);\n\n    return allIds;\n}\n\n/**\n * возвращает все папки внутри data, на любой вложенности\n * @param data обьект сохранения IDataTreeRootFolder\n * @returns\n */\nfunction getAllFolders(data: IDataTreeRootFolder) {\n    const allFolders: IDataTreeFolder[] = [];\n\n    const parser = (node: IDataTreeFolder | IDataTreeNote | TNoteBody) => {\n        if (isDataTreeFolder(node)) {\n            allFolders.push(nodeWithoutChildren(node) as IDataTreeFolder);\n\n            if (!node.children) return;\n            for (let item of node.children) {\n                parser(item);\n            }\n        }\n    };\n\n    parser(data);\n\n    return allFolders;\n}\n\n/**\n * возвращает все заметки внутри data, на любой вложенности\n * @param data обьект сохранения IDataTreeRootFolder\n * @returns\n */\nfunction getAllNotes(data: IDataTreeRootFolder) {\n    const allNotes: IDataTreeNote[] = [];\n\n    const parser = (node: IDataTreeFolder | IDataTreeNote | TNoteBody) => {\n        if (isDataTreeFolder(node)) {\n            if (!node.children) return;\n            for (let item of node.children) {\n                parser(item);\n            }\n        }\n\n        if (isDataTreeNote(node)) {\n            allNotes.push(node);\n        }\n    };\n\n    parser(data);\n\n    return allNotes;\n}\n\n/**\n * ищет родительскую папку для ноды\n * @param rootNode обект типа IDataTreeRootFolder | TchildrenType\n * @param nodeId id ноды для которой нужно отыскать родителя\n */\nfunction getParentFolder(rootNode: IDataTreeFolder, nodeId: string): IDataTreeNote | IDataTreeFolder | TNoteBody | null | undefined {\n    type TTreeElement = IDataTreeNote | IDataTreeFolder | TNoteBody;\n\n    let parent: IDataTreeNote | IDataTreeFolder | IDataTreeRootFolder | TNoteBody;\n\n    parent = rootNode;\n    let result: TTreeElement | null | undefined;\n\n    const finder = (node: TTreeElement): TTreeElement | null | undefined => {\n        if (node.id === nodeId) {\n            if (node.id === parent.id) return undefined;\n            return parent as TTreeElement;\n        }\n\n        if (isDataTreeFolder(node)) {\n            if (node.children) {\n                let saveParent = parent;\n                parent = node;\n                for (let child of node.children) {\n                    let finder_result = finder(child);\n                    if (finder_result === undefined) return null;\n                    if (finder_result) return finder_result;\n                }\n                parent = saveParent;\n            }\n            return null;\n        }\n\n        return null;\n    };\n\n    result = finder(parent);\n\n    return result;\n}\n\nexport { getAllIds, getAllFolders, getAllNotes, getParentFolder };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { IdGenerator } from \"0-shared/utils/idGenerator\";\nimport { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getAllIdsInNode } from \"../saveDataUtilsFunctions/getAllIdsInNode\";\nimport { delImageDB } from \"../appIndexedDBFynctions/imageFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { delTableDB } from \"../appIndexedDBFynctions/tableFunctions\";\nimport type { IDataTreeRootFolder, IDataTreeFolder, TchildrenType } from \"0-shared/types/dataSave\";\n\n/**\n * удаляет ноду типа TchildrenType по id из tempData в indexedDB\n * @param rootNode - обьект сохранения IDataTreeRootFolder\n * @param target_id - id ноды которую нужно удалить\n * @param savedIdGenerator - результат вызова savedIdGenerator.instatnceIdGenerator.getIdsArray()\n */\ntype TReturnTypeDeleteById = ReturnType<typeof deleteById>;\ntype TParametersDeleteById = Parameters<typeof deleteById>;\n\nasync function deleteById(data: { rootNode: IDataTreeRootFolder; target_id: string; savedIdGenerator: string[] }) {\n    let parent: IDataTreeFolder;\n    let deletedNode: TchildrenType | undefined;\n    let resultBool = false;\n    let newIdGenerator = new IdGenerator(new Set(data.savedIdGenerator));\n\n    const finder = (node: TchildrenType) => {\n        if (node.id === data.target_id && node.id !== \"root\") {\n            parent.children = parent.children!.filter((child) => {\n                if (child.id === data.target_id) {\n                    if (isDataTreeFolder(child) || isDataTreeNote(child)) {\n                        const innerIds = getAllIdsInNode(child);\n                        delImageDB({ key: innerIds });\n                        delTableDB({ key: innerIds });\n                        innerIds.map((id) => {\n                            newIdGenerator.deleteId(id);\n                        });\n                    }\n                    newIdGenerator.deleteId(data.target_id);\n                    deletedNode = child;\n                    return false;\n                }\n                return true;\n            });\n            resultBool = true;\n            return true;\n        }\n\n        if (isDataTreeFolder(node)) {\n            if (node.children) {\n                let temp = parent;\n                parent = node;\n                for (let child of node.children) {\n                    let result = finder(child);\n                    if (result) return true;\n                }\n                parent = temp;\n            }\n        }\n    };\n\n    parent = data.rootNode;\n    let result = finder(data.rootNode);\n    if (!result) throw new Error(`node not found`);\n    await setDataTreeDB({ value: data.rootNode });\n    return { deletedNode, resultBool, newIdGenerator: newIdGenerator.getIdsArray() };\n}\n\nexport { deleteById };\nexport type { TReturnTypeDeleteById, TParametersDeleteById };\n","import type { IDataTreeFolder, IDataTreeNote, TNoteBody } from \"0-shared/types/dataSave\";\n\n/**\n * возвращает массив всех вложенных id внутри Node\n * @param node обьект типа IDataTreeFolder | IDataTreeNote внутри которого нужно собрать id\n */\nfunction getAllIdsInNode(node: IDataTreeFolder | IDataTreeNote) {\n    const allIds = new Set<string>();\n\n    const parser = (node: IDataTreeFolder | IDataTreeNote | TNoteBody) => {\n        for (let prop in node) {\n            if (prop === \"id\") {\n                if (allIds.has(node[prop])) throw new Error(\"Duplicate id in tempData\");\n                allIds.add(node[prop]);\n                continue;\n            }\n            if (prop === \"children\") {\n                for (let item of (node as IDataTreeFolder)[prop]!) {\n                    parser(item);\n                }\n            }\n            if (prop === \"body\") {\n                for (let item of (node as IDataTreeNote)[prop]) {\n                    parser(item);\n                }\n            }\n        }\n    };\n\n    parser(node);\n    return Array.from(allIds);\n}\n\nexport { getAllIdsInNode };\n","import { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport type { IDataTreeRootFolder, TchildrenType, TNoteBody } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeGetNodeById = ReturnType<typeof getNodeById>;\ntype TParametersGetNodeById = Parameters<typeof getNodeById>;\n\n/**\n * ищет ноду по заданному id и возвращает ее\n * @param rootNode обект типа IDataTreeRootFolder | TchildrenType | TNoteBody | undefined\n * @param find_id искомый ID\n * @returns\n */\nfunction getNodeById(rootNode: IDataTreeRootFolder | TchildrenType | TNoteBody | undefined, find_id: string) {\n    const finder = (node: TchildrenType | TNoteBody): TchildrenType | TNoteBody | null => {\n        if (node.id === find_id) {\n            return node;\n        }\n\n        if (isDataTreeFolder(node)) {\n            if (node.children) {\n                for (let child of node.children) {\n                    let result = finder(child);\n                    if (result) return result;\n                }\n            }\n        }\n\n        if (isDataTreeNote(node)) {\n            for (let component of node.body) {\n                if (component.id === find_id) {\n                    return component;\n                }\n            }\n        }\n\n        return null;\n    };\n\n    if (rootNode) {\n        let root = rootNode;\n        return finder(root as TchildrenType | TNoteBody);\n    }\n\n    return null;\n}\n\nexport { getNodeById };\nexport type { TReturnTypeGetNodeById, TParametersGetNodeById };\n","import { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getTableDB } from \"2-features/utils/appIndexedDBFynctions/tableFunctions\";\nimport type { IFindNodeParametres } from \"5-app/GlobalState/toolBarStore\";\nimport type { IDataTreeRootFolder, IDataTreeFolder, IDataTreeNote } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeCloneFiltredTree = ReturnType<typeof cloneFiltredTree>;\ntype TParametersCloneFiltredTree = Parameters<typeof cloneFiltredTree>;\n\n/**\n *  функционал для поиска заметок\n *  клонирование исходного дерева с учетом параметров поиска, ненужные ноды игнорируются для клонирования,\n *  если в ходе фильтрации появляются пустые папки они также игнорируются.\n * @param orig_obj обьект data_tree (содеращий все дерево заметок)\n * @param filtres обьект с параметрами поиска\n * @returns [клонированный обьект, Set всех id папок которые есть в клон.обьекте]\n */\nasync function cloneFiltredTree(\n    orig_obj: IDataTreeRootFolder,\n    filtres: IFindNodeParametres | undefined\n): Promise<[clonedObj: IDataTreeFolder, internalFoldersId: Set<string>]> {\n    let clonedObj = { ...orig_obj, children: [] } as IDataTreeFolder;\n    let internalFoldersId: Set<string> = new Set<string>();\n\n    if (!filtres) return [orig_obj, internalFoldersId];\n\n    clonedObj = (await deepClone(orig_obj, clonedObj, filtres, internalFoldersId)) ?? orig_obj;\n    return [clonedObj, internalFoldersId];\n}\n\n/**\n * непосредственно функция клонирования\n */\nasync function deepClone(\n    origNode: IDataTreeFolder,\n    clonedObj: IDataTreeFolder,\n    filtres: IFindNodeParametres,\n    internalFoldersId: Set<string>\n) {\n    if (clonedObj.id === \"root\") !internalFoldersId.has(clonedObj.id) && internalFoldersId.add(clonedObj.id);\n\n    for (let child of (origNode as IDataTreeFolder)[\"children\"]!) {\n        if (isDataTreeNote(child) && (await checkFilter(child, filtres))) {\n            !internalFoldersId.has(origNode.id) && internalFoldersId.add(origNode.id);\n            const cloneNote = structuredClone(child);\n            clonedObj[\"children\"]!.push(cloneNote);\n            continue;\n        }\n\n        if (isDataTreeFolder(child)) {\n            if (child.children && child.children.length > 0) {\n                const copyChildNode = { ...child, children: [] } as IDataTreeFolder;\n                let innderFolder = await deepClone(child, copyChildNode, filtres, internalFoldersId);\n                if (innderFolder.children && innderFolder.children.length > 0) {\n                    clonedObj[\"children\"]!.push(innderFolder);\n                    !internalFoldersId.has(innderFolder.id) && internalFoldersId.add(innderFolder.id);\n                }\n            }\n        }\n    }\n\n    return clonedObj;\n}\n\n/**\n * ф.ция проверяет соответствует-ли заметка требуемым параметрам поиска\n */\nasync function checkFilter(note: IDataTreeNote, filtres: IFindNodeParametres) {\n    let resultName = false;\n    let resultTags = false;\n    let resultContent = false;\n\n    if (filtres.name !== \"\") {\n        if (note.name.includes(filtres.name)) resultName = true;\n    } else {\n        resultName = true;\n    }\n\n    if (filtres.tags.length > 0) {\n        if (filtres.tags.length > 0 && (!note.tags || (note.tags && note.tags.length === 0))) resultTags = false;\n        if (filtres.tags.length > 0 && note.tags && note.tags.length > 0) {\n            let included: string[] = [];\n            for (let findTag of filtres.tags) {\n                if (note.tags.includes(findTag)) included.push(findTag);\n            }\n            if (included.length === filtres.tags.length) resultTags = true;\n        }\n    } else {\n        resultTags = true;\n    }\n\n    if (filtres.content !== \"\") {\n        for (let component of note.body) {\n            if (component.value.includes(filtres.content)) return true;\n\n            if (component.component == \"link\") {\n                return component.isLabel && component.labelValue.includes(filtres.content);\n            }\n\n            if (component.component == \"code\") {\n                return component.isExpand && component.expandDesc.includes(filtres.content);\n            }\n\n            if (component.component == \"image\") {\n                return !component.isDescHidden && component.desc.includes(filtres.content);\n            }\n\n            // TODO: для поиска по содержимому таблицы придется реальзовать всю логику через промисы, поэтому пока отложим\n            if (component.component == \"table\") {\n                if (component.desc && component.desc.includes(filtres.content)) return true;\n\n                if (component.value !== \"\") {\n                    const tableData = await getTableDB({ key: component.value });\n                    if (tableData && tableData.value) {\n                        const JSONTableData = JSON.stringify(tableData.value);\n                        return JSONTableData.includes(filtres.content);\n                    }\n                }\n            }\n        }\n    } else {\n        resultContent = true;\n    }\n\n    return resultName && resultTags && resultContent;\n}\n\nexport { cloneFiltredTree };\nexport type { TReturnTypeCloneFiltredTree, TParametersCloneFiltredTree };\n","import { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport type { IDataTreeRootFolder, TchildrenType, TNoteBody, IDataTreeFolder, IDataTreeNote } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeGetParentNode = ReturnType<typeof getParentNode>;\ntype TParametersGetParentNode = Parameters<typeof getParentNode>;\n\n/**\n * ищет родителя ноды. Родителем может быть как папка (для других папок или заметок) так и заметка (для компонентов)\n * @param rootNode обект типа IDataTreeRootFolder | TchildrenType | TNoteBody\n * @param nodeId id ноды для которой нужно отыскать родителя\n */\nfunction getParentNode(\n    rootNode: IDataTreeRootFolder | TchildrenType | TNoteBody,\n    nodeId: string\n): IDataTreeNote | IDataTreeFolder | TNoteBody | null | undefined {\n    type TTreeElement = IDataTreeNote | IDataTreeFolder | TNoteBody;\n\n    let parent: IDataTreeNote | IDataTreeFolder | IDataTreeRootFolder | TNoteBody;\n\n    parent = rootNode;\n\n    let result: TTreeElement | null | undefined;\n\n    const finder = (node: TTreeElement): TTreeElement | null | undefined => {\n        if (node.id === nodeId) {\n            if (node.id === parent.id) return undefined;\n            return parent as TTreeElement;\n        }\n\n        if (isDataTreeFolder(node)) {\n            if (node.children) {\n                let saveParent = parent;\n                parent = node;\n                for (let child of node.children) {\n                    let finder_result = finder(child);\n                    if (finder_result === undefined) return null;\n                    if (finder_result) return finder_result;\n                }\n                parent = saveParent;\n            }\n            return null;\n        }\n\n        if (isDataTreeNote(node)) {\n            let saveParent = parent;\n            parent = node;\n            for (let component of node.body) {\n                let finder_result = finder(component);\n                if (finder_result === undefined) return null;\n                if (finder_result) return finder_result;\n            }\n            parent = saveParent;\n        }\n\n        return null;\n    };\n\n    result = finder(parent);\n    return result;\n}\n\nexport { getParentNode };\nexport type { TReturnTypeGetParentNode, TParametersGetParentNode };\n","import { DataNode } from \"./saveDataNode\";\nimport { IdGenerator } from \"../idGenerator\";\nimport type { TBodyComponentHeader } from \"0-shared/types/dataSave\";\n\n/**\n *  класс для создания новых компонентов заголовка заметки\n */\nclass DataComponentHeader extends DataNode implements TBodyComponentHeader {\n    public component: TBodyComponentHeader[\"component\"];\n    public value: TBodyComponentHeader[\"value\"];\n    public headerSize: TBodyComponentHeader[\"headerSize\"];\n    public textAligin: TBodyComponentHeader[\"textAligin\"];\n\n    constructor(idGenerator: InstanceType<typeof IdGenerator>) {\n        super(\"component\", idGenerator);\n\n        this.component = \"header\";\n        this.value = \"\";\n        this.headerSize = \"h3\";\n        this.textAligin = \"center\";\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { DataComponentHeader };\n","import { DataNode } from \"./saveDataNode\";\nimport { IdGenerator } from \"../idGenerator\";\nimport type { TBodyComponentText } from \"0-shared/types/dataSave\";\n\n/**\n *  класс для создания новых компонентов текста заметки\n */\nclass saveDataComponentText extends DataNode implements TBodyComponentText {\n    public component: TBodyComponentText[\"component\"];\n    public value: TBodyComponentText[\"value\"];\n    public background: TBodyComponentText[\"background\"];\n    public formatting: TBodyComponentText[\"formatting\"];\n    public font: TBodyComponentText[\"font\"];\n    public lineBreak: TBodyComponentText[\"lineBreak\"];\n\n    constructor(idGenerator: InstanceType<typeof IdGenerator>) {\n        super(\"component\", idGenerator);\n\n        this.component = \"text\";\n        this.value = \"\";\n        this.background = false;\n        this.font = \"default\";\n        this.formatting = true;\n        this.lineBreak = true;\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { saveDataComponentText };\n","import { DataNode } from \"./saveDataNode\";\nimport { IdGenerator } from \"../idGenerator\";\nimport type { TBodyComponentCode } from \"0-shared/types/dataSave\";\n\n/**\n *  класс для создания новых компонентов кода заметки\n */\nclass saveDataComponentCode extends DataNode implements TBodyComponentCode {\n    public component: TBodyComponentCode[\"component\"];\n    public value: TBodyComponentCode[\"value\"];\n    public language: TBodyComponentCode[\"language\"];\n    public codeTheme: TBodyComponentCode[\"codeTheme\"];\n    public isExpand: TBodyComponentCode[\"isExpand\"];\n    public expandDesc: TBodyComponentCode[\"expandDesc\"];\n\n    constructor(idGenerator: InstanceType<typeof IdGenerator>) {\n        super(\"component\", idGenerator);\n\n        this.component = \"code\";\n        this.value = \"\";\n        this.language = \"text\";\n        this.codeTheme = \"auto\";\n        this.isExpand = false;\n        this.expandDesc = \"\";\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { saveDataComponentCode };\n","import { DataNode } from \"./saveDataNode\";\nimport { IdGenerator } from \"../idGenerator\";\nimport type { TBodyComponentImage } from \"0-shared/types/dataSave\";\n\n/**\n *  класс для создания новых компонентов картинки заметки\n */\nclass saveDataComponentImage extends DataNode implements TBodyComponentImage {\n    public component: TBodyComponentImage[\"component\"];\n    public value: TBodyComponentImage[\"value\"];\n    public desc: TBodyComponentImage[\"desc\"];\n    public isDescHidden: TBodyComponentImage[\"isDescHidden\"];\n    public fileName: TBodyComponentImage[\"fileName\"];\n\n    constructor(idGenerator: InstanceType<typeof IdGenerator>) {\n        super(\"component\", idGenerator);\n\n        this.component = \"image\";\n        this.value = \"\";\n        this.desc = \"\";\n        this.isDescHidden = false;\n        this.fileName = \"\";\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { saveDataComponentImage };\n","import { DataNode } from \"./saveDataNode\";\nimport { IdGenerator } from \"../idGenerator\";\nimport type { TBodyComponentLink } from \"0-shared/types/dataSave\";\n\n/**\n *  класс для создания новых компонентов ссылок заметки\n */\nclass saveDataComponentLink extends DataNode implements TBodyComponentLink {\n    public component: TBodyComponentLink[\"component\"];\n    public value: TBodyComponentLink[\"value\"];\n    public labelValue: TBodyComponentLink[\"labelValue\"];\n    public isLabel: TBodyComponentLink[\"isLabel\"];\n    public background: TBodyComponentLink[\"background\"];\n    public target: TBodyComponentLink[\"target\"];\n\n    constructor(idGenerator: InstanceType<typeof IdGenerator>) {\n        super(\"component\", idGenerator);\n\n        this.component = \"link\";\n        this.value = \"#\";\n        this.labelValue = \"Link\";\n        this.isLabel = false;\n        this.background = false;\n        this.target = \"web\";\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { saveDataComponentLink };\n","import { DataNode } from \"./saveDataNode\";\nimport { IdGenerator } from \"../idGenerator\";\nimport type { TBodyComponentVideo } from \"0-shared/types/dataSave\";\n\n/**\n *  класс для создания новых компонентов кода заметки\n */\nclass saveDataComponentVideo extends DataNode implements TBodyComponentVideo {\n    public component: TBodyComponentVideo[\"component\"];\n    public value: TBodyComponentVideo[\"value\"];\n\n    constructor(idGenerator: InstanceType<typeof IdGenerator>) {\n        super(\"component\", idGenerator);\n\n        this.component = \"video\";\n        this.value = \"\";\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { saveDataComponentVideo };\n","import { DataNode } from \"./saveDataNode\";\nimport { IdGenerator } from \"../idGenerator\";\nimport type { TBodyComponentList } from \"0-shared/types/dataSave\";\n\n/**\n *  класс для создания новых компонентов заголовка заметки\n */\nclass DataComponentList extends DataNode implements TBodyComponentList {\n    public component: TBodyComponentList[\"component\"];\n    public value: TBodyComponentList[\"value\"];\n    public background: TBodyComponentList[\"background\"];\n    public isNumeric: TBodyComponentList[\"isNumeric\"];\n    public textAligin: TBodyComponentList[\"textAligin\"];\n\n    constructor(idGenerator: InstanceType<typeof IdGenerator>) {\n        super(\"component\", idGenerator);\n\n        this.component = \"list\";\n        this.value = \"\";\n        this.background = false;\n        this.isNumeric = false;\n        this.textAligin = \"left\";\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { DataComponentList };\n","import {\n    isFunctionData,\n    isDelByIdData,\n    isDelCompInNote,\n    isCloneFiltredTree,\n    isUpdateNodeValue,\n    isUpdNoteComponentsOrder,\n    isUpdateNodeImage,\n    isUpdateNodeTable,\n    isUpdateNodeTableSettings,\n    isUpdateNodeLink,\n    isGetNodeById,\n    isUpdateNoteComponentLinkSettings,\n    isUpdateNoteComponentImageSettings,\n    isUpdateNoteComponentTextSettings,\n    isUpdateNoteComponentListSettings,\n    isUpdateNoteComponentHeaderSettings,\n    isUpdateNoteComponentCodeSettings,\n    isUpdateNodeCompleted,\n    isUpdateNodeName,\n    isAddNodeTo,\n    isNodeMuveTo,\n    isNoteDeleteTag,\n    isNoteAddTag,\n    isProjectDeleteTag,\n    isGetParentNode,\n    isProjectEditeTag,\n    isAddNewComponentToNote,\n} from \"0-shared/utils/typeHelpers\";\nimport { deleteById } from \"2-features/utils/saveDataEditFunctions/deleteById\";\nimport { deleteComponentInNote } from \"2-features/utils/saveDataEditFunctions/deleteComponentInNote\";\nimport { cloneFiltredTree } from \"0-shared/utils/note_find\";\nimport { updateNodeValue } from \"2-features/utils/saveDataEditFunctions/updateNoteValue\";\nimport { updNoteComponentsOrder } from \"2-features/utils/saveDataEditFunctions/updNoteComponentsOrder\";\nimport { updateNodeImage } from \"2-features/utils/saveDataEditFunctions/updateNoteImage\";\nimport { updateNodeTable } from \"2-features/utils/saveDataEditFunctions/updateNodeTable\";\nimport { updateNodeTableSettings } from \"2-features/utils/saveDataEditFunctions/updateNodeTableSettings\";\nimport { updateNodeLink } from \"2-features/utils/saveDataEditFunctions/updateNodeLink\";\nimport { getNodeById } from \"2-features/utils/saveDataParseFunctions/getNodeById\";\nimport { updateNoteComponentLinkSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentLinkSettings\";\nimport { updateNoteComponentImageSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentImageSettings\";\nimport { updateNoteComponentTextSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentTextSettings\";\nimport { updateNoteComponentListSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentListSettings\";\nimport { updateNoteComponentHeaderSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentHeaderSettings\";\nimport { updateNoteComponentCodeSettings } from \"2-features/utils/saveDataEditFunctions/componentCodeSettings\";\nimport { updateNodeCompleted } from \"2-features/utils/saveDataEditFunctions/updateNodeCompleted\";\nimport { updateNodeName } from \"2-features/utils/saveDataEditFunctions/updateNodeName\";\nimport { addNodeTo } from \"2-features/utils/saveDataEditFunctions/addNodeTo\";\nimport { nodeMuveTo } from \"2-features/utils/saveDataEditFunctions/nodeMuveTo\";\nimport { noteDeleteTag } from \"2-features/utils/saveDataEditFunctions/noteDeleteTag\";\nimport { noteAddTag } from \"2-features/utils/saveDataEditFunctions/noteAddTag\";\nimport { projectDeleteTag } from \"2-features/utils/saveDataEditFunctions/projectDeleteTag\";\nimport { getParentNode } from \"2-features/utils/saveDataParseFunctions/getParentNode\";\nimport { projectEditeTag } from \"2-features/utils/saveDataEditFunctions/projectEditeTag\";\nimport { addNewComponentToNote } from \"2-features/utils/saveDataEditFunctions/addNewComponentToNote\";\nimport type {\n    TMessageDataType,\n    TMessageDelById,\n    TMessageDelCompInNote,\n    TMessageCloneFiltredTreeOnWorker,\n    TMessageUpdateNodeValueOnWorker,\n    TMessageUpdNoteComponentsOrderOnWorker,\n    TMessageUpdateNodeImageOnWorker,\n    TMessageUpdateNodeTableOnWorker,\n    TMessageUpdateNodeTableSettingsOnWorker,\n    TMessageUpdateNodeLinkOnWorker,\n    TMessageGetNodeByIdOnWorker,\n    TMessageUpdateNoteComponentLinkSettingsOnWorker,\n    TMessageUpdateNoteComponentImageSettingsOnWorker,\n    TMessageUpdateNoteComponentTextSettingsOnWorker,\n    TMessageUpdateNoteComponentListSettingsOnWorker,\n    TMessageUpdateNoteComponentHeaderSettingsOnWorker,\n    TMessageUpdateNoteComponentCodeSettingsOnWorker,\n    TMessageUpdateNodeCompletedOnWorker,\n    TMessageUpdateNodeNameOnWorker,\n    TMessageAddNodeToOnWorker,\n    TMessageNodeMuveToOnWorker,\n    TMessageNoteDeleteTagOnWorker,\n    TMessageNoteAddTagOnWorker,\n    TMessageProjectDeleteTagOnWorker,\n    TMessageGetParentNodeOnWorker,\n    TMessageProjectEditeTagOnWorker,\n    TMessageAddNewComponentToNoteOnWorker,\n} from \"./workerTypes\";\n\ntype TTaskRunerTypes =\n    | TMessageDelById\n    | TMessageDelCompInNote\n    | TMessageCloneFiltredTreeOnWorker\n    | TMessageUpdateNodeValueOnWorker\n    | TMessageUpdNoteComponentsOrderOnWorker\n    | TMessageUpdateNodeImageOnWorker\n    | TMessageUpdateNodeTableOnWorker\n    | TMessageUpdateNodeTableSettingsOnWorker\n    | TMessageUpdateNodeLinkOnWorker\n    | TMessageGetNodeByIdOnWorker\n    | TMessageUpdateNoteComponentLinkSettingsOnWorker\n    | TMessageUpdateNoteComponentImageSettingsOnWorker\n    | TMessageUpdateNoteComponentTextSettingsOnWorker\n    | TMessageUpdateNoteComponentListSettingsOnWorker\n    | TMessageUpdateNoteComponentHeaderSettingsOnWorker\n    | TMessageUpdateNoteComponentCodeSettingsOnWorker\n    | TMessageUpdateNodeCompletedOnWorker\n    | TMessageUpdateNodeNameOnWorker\n    | TMessageAddNodeToOnWorker\n    | TMessageNodeMuveToOnWorker\n    | TMessageNoteDeleteTagOnWorker\n    | TMessageNoteAddTagOnWorker\n    | TMessageProjectDeleteTagOnWorker\n    | TMessageGetParentNodeOnWorker\n    | TMessageProjectEditeTagOnWorker\n    | TMessageAddNewComponentToNoteOnWorker;\n\n/**\n * получение данных\n */\n//eslint-disable-next-line\nself.onmessage = (e: MessageEvent) => {\n    const data = e.data;\n    if (!data) return;\n\n    if (isFunctionData(data)) {\n        funcExecutorCase(data);\n        return;\n    }\n\n    if (\n        isUpdateNoteComponentImageSettings(data) ||\n        isUpdateNoteComponentLinkSettings(data) ||\n        isGetNodeById(data) ||\n        isUpdateNodeLink(data) ||\n        isUpdateNodeTableSettings(data) ||\n        isUpdateNodeTable(data) ||\n        isUpdateNodeImage(data) ||\n        isUpdNoteComponentsOrder(data) ||\n        isUpdateNodeValue(data) ||\n        isCloneFiltredTree(data) ||\n        isDelCompInNote(data) ||\n        isDelByIdData(data) ||\n        isUpdateNoteComponentTextSettings(data) ||\n        isUpdateNoteComponentListSettings(data) ||\n        isUpdateNoteComponentHeaderSettings(data) ||\n        isUpdateNoteComponentCodeSettings(data) ||\n        isUpdateNodeCompleted(data) ||\n        isUpdateNodeName(data) ||\n        isAddNodeTo(data) ||\n        isNodeMuveTo(data) ||\n        isNoteDeleteTag(data) ||\n        isNoteAddTag(data) ||\n        isProjectDeleteTag(data) ||\n        isGetParentNode(data) ||\n        isProjectEditeTag(data) ||\n        isAddNewComponentToNote(data)\n    ) {\n        taskRuner(data);\n        return;\n    }\n};\n\n/**\n * отправка данных в рантайм\n */\nfunction worker_postMessage(resolve: string = \"\", work_data: any = null) {\n    //eslint-disable-next-line\n    self.postMessage({\n        resolve: resolve,\n        work_data: work_data,\n    });\n}\n\n/**\n * кейс с выполнением функции\n */\nfunction funcExecutorCase({ argument_names = [], argument_values = [], func_data = \"\" }: TMessageDataType) {\n    if (func_data) {\n        worker_postMessage(\"Function executor: started\");\n        func_runer(argument_names, argument_values, func_data);\n    }\n}\n\n/**\n * создание и выполнение полученной функции\n */\nfunction func_runer(argument_names: string[], argument_values: any[], func_data: string) {\n    try {\n        const func = new Function(...argument_names, func_data);\n        const result = func(...argument_values);\n        worker_postMessage(\"Function executor: finished\", result);\n    } catch (e) {\n        worker_postMessage(\"Function executor: error\");\n        console.error(e);\n    }\n}\n\nasync function taskRuner(data: TTaskRunerTypes) {\n    try {\n        worker_postMessage(`${data.type}: started`);\n        console.info(`dedicatedWorker.taskRuner: type '${data.type}'`);\n        let result: any = undefined;\n\n        switch (data.type) {\n            case \"update note component image settings\":\n                result = await updateNoteComponentImageSettings(data);\n                break;\n            case \"clone filtred tree\":\n                result = await cloneFiltredTree(...data.args);\n                break;\n            case \"delete by id\":\n                result = await deleteById(data);\n                break;\n            case \"delete component in note\":\n                result = await deleteComponentInNote(data);\n                break;\n            case \"get node by id\":\n                result = getNodeById(...data.args);\n                break;\n            case \"update Note component link settings\":\n                result = await updateNoteComponentLinkSettings(data);\n                break;\n            case \"update node image\":\n                result = await updateNodeImage(data);\n                break;\n            case \"update node link\":\n                result = await updateNodeLink(data);\n                break;\n            case \"update node table\":\n                result = await updateNodeTable(data);\n                break;\n            case \"update node table settings\":\n                result = await updateNodeTableSettings(data);\n                break;\n            case \"update node value\":\n                result = await updateNodeValue(data);\n                break;\n            case \"update note components order\":\n                result = await updNoteComponentsOrder(data);\n                break;\n            case \"update note component text settings\":\n                result = await updateNoteComponentTextSettings(data);\n                break;\n            case \"update note component list settings\":\n                result = await updateNoteComponentListSettings(data);\n                break;\n            case \"update note component header settings\":\n                result = await updateNoteComponentHeaderSettings(data);\n                break;\n            case \"update note component code settings\":\n                result = await updateNoteComponentCodeSettings(data);\n                break;\n            case \"update node completed\":\n                result = await updateNodeCompleted(data);\n                break;\n            case \"update node name\":\n                result = await updateNodeName(data);\n                break;\n            case \"add node to\":\n                result = await addNodeTo(data);\n                break;\n            case \"node move to\":\n                result = await nodeMuveTo(data);\n                break;\n            case \"note delete tag\":\n                result = await noteDeleteTag(data);\n                break;\n            case \"note add tag\":\n                result = await noteAddTag(data);\n                break;\n            case \"project delete tag\":\n                result = await projectDeleteTag(data);\n                break;\n            case \"get parent node\":\n                result = await getParentNode(...data.args);\n                break;\n            case \"project edite tag\":\n                result = await projectEditeTag(data);\n                break;\n            case \"add new component to note\":\n                result = await addNewComponentToNote(data);\n                break;\n            default:\n                console.error(`dedicatedWorker.taskRuner: task type error, task '${(data as any).type}' unknown`);\n                throw new Error();\n        }\n\n        worker_postMessage(`${data.type}: finished`, result);\n    } catch (e) {\n        worker_postMessage(`${data.type}: error`);\n        console.error(e);\n    }\n}\n","import { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentImageSettings = ReturnType<typeof updateNoteComponentImageSettings>;\ntype TParametersUpdateNoteComponentImageSettings = Parameters<typeof updateNoteComponentImageSettings>;\n\n/**\n * изменяет настройки компонента image в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняются данные\n * @param imageDesc новое описание\n * @param isDescHidden нужноли скрыть описание\n */\nasync function updateNoteComponentImageSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    imageDesc: string;\n    isDescHidden: boolean;\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"image\") {\n                component.desc = data.imageDesc;\n                component.isDescHidden = data.isDescHidden;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentImageSettings };\nexport type { TReturnTypeUpdateNoteComponentImageSettings, TParametersUpdateNoteComponentImageSettings };\n","import type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { delImageDB } from \"../appIndexedDBFynctions/imageFunctions\";\nimport { delTableDB } from \"../appIndexedDBFynctions/tableFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { IdGenerator } from \"0-shared/utils/idGenerator\";\n\ntype TReturnTypeDeleteComponentInNote = ReturnType<typeof deleteComponentInNote>;\ntype TParametersDeleteComponentInNote = Parameters<typeof deleteComponentInNote>;\n\n/**\n * удаление компонента из заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteID id заметки\n * @param componentID id компонента который нужно удалить\n */\nasync function deleteComponentInNote(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteID: string;\n    componentID: string;\n    savedIdGenerator: string[];\n}) {\n    let newIdGenerator = new IdGenerator(new Set(data.savedIdGenerator));\n    let resultBool = false;\n\n    let targetNote = getNodeById(data.rootFolder, data.noteID);\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        targetNote.body = targetNote.body.filter((item) => {\n            if (item.id === data.componentID) {\n                newIdGenerator.deleteId(data.componentID);\n                if (item.component == \"image\") {\n                    delImageDB({ key: item.id });\n                    item.value = \"\";\n                }\n                if (item.component == \"table\") {\n                    delTableDB({ key: item.id });\n                    item.value = \"\";\n                }\n                return false;\n            }\n            return true;\n        });\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool, newIdGenerator: newIdGenerator.getIdsArray() };\n}\n\nexport { deleteComponentInNote };\nexport type { TReturnTypeDeleteComponentInNote, TParametersDeleteComponentInNote };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, TBodyComponentLink } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentLinkSettings = ReturnType<typeof updateNoteComponentLinkSettings>;\ntype TParametersUpdateNoteComponentLinkSettings = Parameters<typeof updateNoteComponentLinkSettings>;\n\n/**\n * изменяет настройки компонента ссылки в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняются данные\n * @param isLabel новое значение isLabel\n * @param isBg новое значение isBg\n * @param labelVal новое значение labelVal\n */\nasync function updateNoteComponentLinkSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    isLabel: TBodyComponentLink[\"isLabel\"];\n    isBg: TBodyComponentLink[\"background\"];\n    labelVal: TBodyComponentLink[\"labelValue\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"link\") {\n                component.background = data.isBg;\n                component.isLabel = data.isLabel;\n                component.labelValue = data.labelVal;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentLinkSettings };\nexport type { TReturnTypeUpdateNoteComponentLinkSettings, TParametersUpdateNoteComponentLinkSettings };\n","import { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { setImageDB } from \"../appIndexedDBFynctions/imageFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeImage = ReturnType<typeof updateNodeImage>;\ntype TParametersUpdateNodeImage = Parameters<typeof updateNodeImage>;\n\n/**\n * изменяет компонент картинки в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param newValue новое значение value\n * @returns\n */\nasync function updateNodeImage(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    newSrc: string;\n    newName: string;\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    // TODO: потом нужно это оптимизировать\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"image\") {\n                component.fileName = data.newName;\n\n                if (data.newSrc === \"\") {\n                    component.value = \"\";\n                    component.desc = \"\";\n                } else {\n                    component.value = component.id;\n                }\n                setImageDB({\n                    value: {\n                        id: data.componentId,\n                        src: data.newSrc,\n                    },\n                    key: component.id,\n                });\n            }\n            break;\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeImage };\nexport type { TReturnTypeUpdateNodeImage, TParametersUpdateNodeImage };\n","import { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport type { IDataTreeRootFolder, TBodyComponentLink } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeLink = ReturnType<typeof updateNodeLink>;\ntype TParametersUpdateNodeLink = Parameters<typeof updateNodeLink>;\n\n/**\n * изменяет компонент ссылки в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param target новое значение target\n * @param value новое значение value\n */\nasync function updateNodeLink(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    target: TBodyComponentLink[\"target\"];\n    value: TBodyComponentLink[\"value\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"link\") {\n                component.target = data.target;\n                component.value = data.value;\n            }\n            break;\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeLink };\nexport type { TReturnTypeUpdateNodeLink, TParametersUpdateNodeLink };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { delTableDB, setTableDB } from \"../appIndexedDBFynctions/tableFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { TTableValue } from \"0-shared/types/dataSave\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeTable = ReturnType<typeof updateNodeTable>;\ntype TParametersUpdateNodeTable = Parameters<typeof updateNodeTable>;\n\n/**\n * изменяет компонент таблицы в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param newValue новое значение TTableValue\n * @returns\n */\nasync function updateNodeTable(data: { rootFolder: IDataTreeRootFolder; noteId: string; componentId: string; newValue: TTableValue | \"\" }) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    // TODO: потом нужно это оптимизировать\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"table\") {\n                if (data.newValue === \"\") {\n                    component.value = \"\";\n                    delTableDB({ key: data.componentId });\n                } else {\n                    component.value = data.componentId;\n                    setTableDB({\n                        value: {\n                            id: data.componentId,\n                            value: data.newValue,\n                        },\n                        key: data.componentId,\n                    });\n                }\n            }\n            break;\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeTable };\nexport type { TReturnTypeUpdateNodeTable, TParametersUpdateNodeTable };\n","import { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport type { TBodyComponentTable, IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeTableSettings = ReturnType<typeof updateNodeTableSettings>;\ntype TParametersUpdateNodeTableSettings = Parameters<typeof updateNodeTableSettings>;\n\n/**\n * изменяет настройки компонента таблицы в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param backlight подцветка строк\n * @param desc описание таблицы\n * @param viewButtons элементы управления в режиме просмотра\n * @returns\n */\nasync function updateNodeTableSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    backlight: TBodyComponentTable[\"backlight\"];\n    desc: TBodyComponentTable[\"desc\"];\n    viewButtons: TBodyComponentTable[\"viewButtons\"];\n    aligin: TBodyComponentTable[\"aligin\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"table\") {\n                component.backlight = data.backlight;\n                component.desc = data.desc;\n                component.viewButtons = data.viewButtons;\n                component.aligin = data.aligin;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeTableSettings };\nexport type { TReturnTypeUpdateNodeTableSettings, TParametersUpdateNodeTableSettings };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeValue = ReturnType<typeof updateNodeValue>;\ntype TParametersUpdateNodeValue = Parameters<typeof updateNodeValue>;\n\n/**\n * изменяет своиство value в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param newValue новое значение value\n * @returns\n */\nasync function updateNodeValue(data: { rootFolder: IDataTreeRootFolder; noteId: string; componentId: string; newValue: string }) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    // TODO: потом нужно это оптимизировать\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            component.value = data.newValue;\n            break;\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeValue };\nexport type { TReturnTypeUpdateNodeValue, TParametersUpdateNodeValue };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { moveElement } from \"0-shared/utils/arrayFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdNoteComponentsOrder = ReturnType<typeof updNoteComponentsOrder>;\ntype TParametersUpdNoteComponentsOrder = Parameters<typeof updNoteComponentsOrder>;\n\n/**\n * меняет порядок компонентов в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой меняем компоненты местами\n * @param componentDragId id компонента который двигаем\n * @param toComponentDragId id компонента на место которого поставим \"componentDragId\"\n */\nasync function updNoteComponentsOrder(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentDragId: string;\n    toComponentDragId: string;\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        let dragComponentIndex: number | null = null;\n        let toComponentIndex: number | null = null;\n\n        for (let i = 0; i < targetNote.body.length; i++) {\n            if (dragComponentIndex && toComponentIndex) {\n                break;\n            }\n            if (targetNote.body[i].id === data.componentDragId) {\n                dragComponentIndex = i;\n                continue;\n            }\n            if (targetNote.body[i].id === data.toComponentDragId) {\n                toComponentIndex = i;\n                continue;\n            }\n        }\n\n        if (dragComponentIndex !== null && toComponentIndex !== null) {\n            targetNote.body = moveElement(targetNote.body, dragComponentIndex, toComponentIndex);\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updNoteComponentsOrder };\nexport type { TReturnTypeUpdNoteComponentsOrder, TParametersUpdNoteComponentsOrder };\n","/**\n * сдвигает все элементы массива та кчтобы fromIndex оказался на позиции toIndex, при этом остальные элементы сдвигаются заполняя освободившееся место\n * @param arr - массив элементов\n * @param fromIndex - индекс который нукжно переместить\n * @param toIndex - индекс куда нужно переменстить fromIndex\n * @returns новый массив\n */\nfunction moveElement(arr: any[], fromIndex: number, toIndex: number): any[] {\n    let copyArr = [...arr];\n    const temp = copyArr[fromIndex];\n\n    if (fromIndex < toIndex) {\n        for (let i = fromIndex; i < toIndex; i++) {\n            copyArr[i] = copyArr[i + 1];\n        }\n    } else {\n        for (let i = fromIndex; i > toIndex; i--) {\n            copyArr[i] = copyArr[i - 1];\n        }\n    }\n\n    copyArr[toIndex] = temp;\n    return copyArr;\n}\n\nexport { moveElement };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, TBodyComponentText } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentTextSettings = ReturnType<typeof updateNoteComponentTextSettings>;\ntype TParametersUpdateNoteComponentTextSettings = Parameters<typeof updateNoteComponentTextSettings>;\n\n/**\n * изменяет настройки компонента текста в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param textBackground значение фона для текста\n * @param textFormat нужноли форматировать текст\n * @param fontValue тип шрифта для текста\n * @param lineBreak автоматический перенос строк\n */\nasync function updateNoteComponentTextSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    textBackground: boolean;\n    textFormat: boolean;\n    fontValue: TBodyComponentText[\"font\"];\n    lineBreak: boolean;\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"text\") {\n                component.background = data.textBackground;\n                component.font = data.fontValue;\n                component.formatting = data.textFormat;\n                component.lineBreak = data.lineBreak;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentTextSettings };\nexport type { TReturnTypeUpdateNoteComponentTextSettings, TParametersUpdateNoteComponentTextSettings };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, TBodyComponentList } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentListSettings = ReturnType<typeof updateNoteComponentListSettings>;\ntype TParametersUpdateNoteComponentListSettings = Parameters<typeof updateNoteComponentListSettings>;\n\n/**\n * изменяет настройки компонента списка в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param listBg значение фона для списка\n * @param isNumeric установить номеруемый тип\n */\nasync function updateNoteComponentListSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    listBg: TBodyComponentList[\"background\"];\n    isNumeric: TBodyComponentList[\"isNumeric\"];\n    aligin: TBodyComponentList[\"textAligin\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"list\") {\n                component.background = data.listBg;\n                component.isNumeric = data.isNumeric;\n                component.textAligin = data.aligin;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentListSettings };\nexport type { TReturnTypeUpdateNoteComponentListSettings, TParametersUpdateNoteComponentListSettings };\n","import { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport type { IDataTreeRootFolder, TBodyComponentHeader } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentHeaderSettings = ReturnType<typeof updateNoteComponentHeaderSettings>;\ntype TParametersUpdateNoteComponentHeaderSettings = Parameters<typeof updateNoteComponentHeaderSettings>;\n\n/**\n * изменяет настройки компонента заголовка в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param textAligin выравнивание текста\n * @param headerSize размер заголовка\n */\nasync function updateNoteComponentHeaderSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    textAligin: TBodyComponentHeader[\"textAligin\"];\n    headerSize: TBodyComponentHeader[\"headerSize\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"header\") {\n                component.headerSize = data.headerSize;\n                component.textAligin = data.textAligin;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentHeaderSettings };\nexport type { TReturnTypeUpdateNoteComponentHeaderSettings, TParametersUpdateNoteComponentHeaderSettings };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, TBodyComponentCode } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentCodeSettings = ReturnType<typeof updateNoteComponentCodeSettings>;\ntype TParametersUpdateNoteComponentCodeSettings = Parameters<typeof updateNoteComponentCodeSettings>;\n\n/**\n * изменяет настройки компонента кода в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param codeTheme цветовая тема кода\n * @param codeLanguage язык кода (для подцветки синтаксиса)\n */\nasync function updateNoteComponentCodeSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    codeTheme: TBodyComponentCode[\"codeTheme\"];\n    codeLanguage: TBodyComponentCode[\"language\"];\n    isExpand: TBodyComponentCode[\"isExpand\"];\n    expandDesc: TBodyComponentCode[\"expandDesc\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"code\") {\n                component.codeTheme = data.codeTheme;\n                component.language = data.codeLanguage;\n                component.isExpand = data.isExpand;\n                component.expandDesc = data.expandDesc;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentCodeSettings };\nexport type { TReturnTypeUpdateNoteComponentCodeSettings, TParametersUpdateNoteComponentCodeSettings };\n","import { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeCompleted = ReturnType<typeof updateNodeCompleted>;\ntype TParametersUpdateNodeCompleted = Parameters<typeof updateNodeCompleted>;\n\n/**\n * изменяет своиство completed в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой нужно поменять completed\n * @param newValue новое значение completed\n * @returns\n */\nasync function updateNodeCompleted(data: { rootFolder: IDataTreeRootFolder; noteId: string; newValue: boolean }) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        if (targetNote.completed !== data.newValue) {\n            targetNote.completed = data.newValue;\n            resultBool = true;\n            targetNote.lastEditTime = Date.now();\n            await setDataTreeDB({ value: data.rootFolder });\n        }\n        resultBool = true;\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeCompleted };\nexport type { TParametersUpdateNodeCompleted, TReturnTypeUpdateNodeCompleted };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote, isDataTreeFolder } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeName = ReturnType<typeof updateNodeName>;\ntype TParametersUpdateNodeName = Parameters<typeof updateNodeName>;\n\n/**\n * изменяет своиство Name в ноде дерева\n * @param rootFolder обьект IDataTreeRootFolder\n * @param target_id id компонента в котором нужно поменять Name\n * @param newName новое значение Name\n */\nasync function updateNodeName(data: { rootFolder: IDataTreeRootFolder; target_id: string; newName: string }) {\n    let targetNode = getNodeById(data.rootFolder, data.target_id);\n    let resultBool = false;\n\n    if ((targetNode && isDataTreeFolder(targetNode)) || isDataTreeNote(targetNode)) {\n        targetNode.name = data.newName;\n        resultBool = true;\n        if (isDataTreeNote(targetNode)) {\n            targetNode.lastEditTime = Date.now();\n        }\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNode, resultBool };\n}\n\nexport { updateNodeName };\nexport type { TReturnTypeUpdateNodeName, TParametersUpdateNodeName };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeFolder, isDataTreeNote, isDataNoteBody } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { DataFolder } from \"0-shared/utils/classes/saveDataFolder\";\nimport type { DataNote } from \"0-shared/utils/classes/saveDataNote\";\nimport type { IDataTreeRootFolder, TchildrenType, TNoteBody, IDataTreeFolder, IDataTreeNote } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeAddNodeTo = ReturnType<typeof addNodeTo>;\ntype TParametersAddNodeTo = Parameters<typeof addNodeTo>;\n\n/**\n * Добавляет ноду в дерево\n * @param rootFolder - обьект сохранения IDataTreeRootFolder\n * @param insertToId - id ноды в которую нужно добавить\n * @param newNode - обьект новой ноды (классы из 0-shared/utils/saveData... .ts)\n */\nasync function addNodeTo(data: {\n    rootFolder: IDataTreeRootFolder;\n    insertToId: string;\n    newNode: TchildrenType | TNoteBody | DataNote | DataFolder;\n}): Promise<{ newNode: null | IDataTreeFolder | IDataTreeNote | TNoteBody; resultBool: boolean }> {\n    let targetNode = getNodeById(data.rootFolder, data.insertToId);\n    let resultBool = false;\n\n    if (!targetNode) return { newNode: null, resultBool };\n\n    // в папку мы можем добавить другую папку или заметку\n    if (isDataTreeFolder(targetNode) && (isDataTreeFolder(data.newNode) || isDataTreeNote(data.newNode))) {\n        if (!targetNode.children) targetNode.children = [];\n        targetNode.children.push(data.newNode);\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n        return { newNode: data.newNode, resultBool };\n    }\n\n    // в заметку мы можем добавить компонент\n    if (isDataTreeNote(targetNode) && isDataNoteBody(data.newNode)) {\n        targetNode.body.push(data.newNode);\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n        return { newNode: data.newNode, resultBool };\n    }\n\n    return { newNode: null, resultBool };\n}\n\nexport { addNodeTo };\nexport type { TReturnTypeAddNodeTo, TParametersAddNodeTo };\n","import { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { getParentNode } from \"../saveDataParseFunctions/getParentNode\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport type { IDataTreeRootFolder, IDataTreeFolder, IDataTreeNote, TNoteBody } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeNodeMuveTo = ReturnType<typeof nodeMuveTo>;\ntype TParametersNodeMuveTo = Parameters<typeof nodeMuveTo>;\n\n/**\n * перемещает заметку или папку в другую папку\n * @param rootFolder - обьект сохранения IDataTreeRootFolder\n * @param muvedNodeID - id ноды которую перемещаем\n * @param muveToID - id ноды куда перемещаем\n */\nasync function nodeMuveTo(data: {\n    rootFolder: IDataTreeRootFolder;\n    muvedNodeID: string;\n    muveToID: string;\n}): Promise<{ muvedNode: IDataTreeFolder | IDataTreeNote | TNoteBody | null; resultBool: boolean }> {\n    let muvedNode = getNodeById(data.rootFolder, data.muvedNodeID);\n    let muvedNodeParent = muvedNode && getParentNode(data.rootFolder, muvedNode.id);\n    let moveToNode = getNodeById(data.rootFolder, data.muveToID);\n    let resultBool = false;\n\n    if (!muvedNode || !muvedNodeParent || !moveToNode) return { muvedNode: null, resultBool };\n    if (muvedNode.id === \"root\") return { muvedNode: muvedNode, resultBool };\n    if (getNodeById(muvedNode, moveToNode.id)) return { muvedNode: muvedNode, resultBool }; // чтобы нельзя было переместить папку в ее дочернюю папку\n    if (muvedNodeParent.id === moveToNode.id) return { muvedNode, resultBool }; // если, откуда = куда перемещаем то ничего не делаем\n    if (moveToNode.id === data.muvedNodeID) return { muvedNode, resultBool }; // чтобы нельзя было перемещать элементы самих в себя\n\n    // убераем muvedNode из дочерних элементов muvedNodeParent\n    if (isDataTreeFolder(muvedNodeParent)) {\n        muvedNodeParent.children = muvedNodeParent.children!.filter((element) => {\n            if (element.id === muvedNode!.id) return false;\n            return true;\n        });\n    }\n\n    if (isDataTreeFolder(moveToNode)) {\n        if (!isDataTreeFolder(muvedNode) && !isDataTreeNote(muvedNode)) return { muvedNode: null, resultBool };\n        if (!moveToNode.children) moveToNode.children = [];\n        moveToNode.children.push(muvedNode);\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n        return { muvedNode, resultBool };\n    }\n\n    return { muvedNode: null, resultBool };\n}\n\nexport { nodeMuveTo };\nexport type { TReturnTypeNodeMuveTo, TParametersNodeMuveTo };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, IGlobalTag } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeNoteDeleteTag = ReturnType<typeof noteDeleteTag>;\ntype TParametersNoteDeleteTag = Parameters<typeof noteDeleteTag>;\n\n/**\n * удаляет тег у заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param targetNoteID id заметки в которой удаляем\n * @param tag обьект тега который нужно убрать\n */\nasync function noteDeleteTag(data: { rootFolder: IDataTreeRootFolder; targetNoteID: string; tag: IGlobalTag }) {\n    let targetNote = getNodeById(data.rootFolder, data.targetNoteID);\n    let resultBool = false;\n\n    if (!targetNote) return { targetNote: null, resultBool };\n    if (!isDataTreeNote(targetNote)) return { targetNote: null, resultBool };\n    if (!(\"tags\" in targetNote)) return { targetNote: null, resultBool };\n\n    targetNote.tags = targetNote.tags!.filter((tagName) => {\n        if (tagName === data.tag.tag_name) return false;\n        return true;\n    });\n\n    targetNote.lastEditTime = Date.now();\n    resultBool = true;\n    await setDataTreeDB({ value: data.rootFolder });\n\n    return { targetNote, resultBool };\n}\n\nexport { noteDeleteTag };\nexport type { TReturnTypeNoteDeleteTag, TParametersNoteDeleteTag };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { getGlobalTagsDB } from \"../appIndexedDBFynctions/globalTagsFunctions\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeNoteAddTag = ReturnType<typeof noteAddTag>;\ntype TParametersNoteAddTag = Parameters<typeof noteAddTag>;\n\n/**\n * добавляет тег в заметку\n * @param rootFolder обьект IDataTreeRootFolder\n * @param targetNoteID id заметки в которую добавляем\n * @param tag имена тегов которые нужно добавить\n */\nasync function noteAddTag(data: { rootFolder: IDataTreeRootFolder; targetNoteID: string; tag: string | string[] }) {\n    let targetNote = getNodeById(data.rootFolder, data.targetNoteID);\n    const allTags = await getGlobalTagsDB();\n    let prepareTags: string[] = [];\n    let resultBool = false;\n\n    if (!allTags) return { targetNote: null, resultBool };\n\n    if (Array.isArray(data.tag) && data.tag.length > 0) {\n        for (let tagItem of data.tag) {\n            if (!(tagItem in allTags)) return { targetNote: null, resultBool };\n        }\n        prepareTags = [...data.tag];\n    }\n\n    if (typeof data.tag === \"string\" && data.tag !== \"\") {\n        if (!(data.tag in allTags)) {\n            return { targetNote: null, resultBool };\n        }\n        prepareTags.push(data.tag);\n    }\n\n    if (!targetNote) return { targetNote: null, resultBool };\n    if (!isDataTreeNote(targetNote)) return { targetNote: null, resultBool };\n\n    if (!(\"tags\" in targetNote)) {\n        targetNote.tags = [];\n    }\n\n    targetNote.tags = targetNote.tags!.concat(prepareTags);\n    targetNote.lastEditTime = Date.now();\n\n    resultBool = true;\n    await setDataTreeDB({ value: data.rootFolder });\n\n    return { targetNote, resultBool };\n}\n\nexport { noteAddTag };\nexport type { TReturnTypeNoteAddTag, TParametersNoteAddTag };\n","import { getAllNotes } from \"../saveDataParse\";\nimport { setGlobalTagsDB } from \"../appIndexedDBFynctions/globalTagsFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, IAllTags } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeProjectDeleteTag = ReturnType<typeof projectDeleteTag>;\ntype TParametersProjectDeleteTag = Parameters<typeof projectDeleteTag>;\n\n/**\n * удаляет тег из проекта\n * @param tagData обьект\n * @param rootFolder обьект IDataTreeRootFolder\n * @param tagName - имя тега который нужно удалить\n */\nasync function projectDeleteTag(data: { tagData: IAllTags; rootFolder: IDataTreeRootFolder; tagName: string }) {\n    let resultBool = false;\n\n    if (data.tagName in data.tagData) {\n        delete data.tagData[data.tagName];\n        const allNotes = getAllNotes(data.rootFolder);\n\n        for (let note of allNotes) {\n            if (!note.tags) continue;\n            note.tags = note.tags.filter((tag) => {\n                if (tag === data.tagName) return false;\n                return true;\n            });\n        }\n\n        // удалить этот тег из всех заметок\n        resultBool = true;\n        await setGlobalTagsDB({ value: data.tagData });\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { tagName: data.tagName, resultBool };\n}\n\nexport { projectDeleteTag };\nexport type { TReturnTypeProjectDeleteTag, TParametersProjectDeleteTag };\n","import { getAllNotes } from \"../saveDataParse\";\nimport { DataTag } from \"0-shared/utils/classes/saveDataTag\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { setGlobalTagsDB } from \"../appIndexedDBFynctions/globalTagsFunctions\";\nimport type { IAllTags, IDataTreeRootFolder, TTagColors } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeProjectEditeTag = ReturnType<typeof projectEditeTag>;\ntype TParametersProjectEditeTag = Parameters<typeof projectEditeTag>;\n\n/**\n * изменяет тег во всем проекте\n * @param tagData обьект\n * @param rootFolder обьект IDataTreeRootFolder\n * @param oldTagName - старое имя тега\n * @param newTagName - новое имя тега\n * @param newTagColor - новый цвет тега\n */\nasync function projectEditeTag(data: {\n    tagData: IAllTags;\n    rootFolder: IDataTreeRootFolder;\n    oldTagName: string;\n    newTagName: string;\n    newTagColor: TTagColors;\n}) {\n    // так как теги в db хранятся в обьекте по (ключу = имя тега), если имя изменилось то и ключ должен изменится\n    // TODO: возможно в будующем добавлю тегам id и в качестве ключа к тегу будет его id, это серьезно упростит работу с изменением тегов, + положительно скажется на визуальном отображаении. (речь идет о том как рендерится список с key в react ), ведь key равен имяни тега а значит и ключу в db\n    let resultBool = false;\n\n    if (data.oldTagName !== data.newTagName) {\n        if (!(data.newTagName in data.tagData)) {\n            delete data.tagData[data.oldTagName];\n            data.tagData[data.newTagName] = new DataTag(data.newTagName, data.newTagColor);\n            const allNotes = getAllNotes(data.rootFolder);\n\n            for (let note of allNotes) {\n                if (!note.tags) continue;\n                const indexTagOldName = note.tags.indexOf(data.oldTagName);\n                if (indexTagOldName !== -1) {\n                    note.tags[indexTagOldName] = data.newTagName;\n                }\n            }\n            resultBool = true;\n            await setDataTreeDB({ value: data.rootFolder });\n        }\n    } else {\n        resultBool = true;\n        data.tagData[data.oldTagName].color = data.newTagColor;\n    }\n\n    await setGlobalTagsDB({ value: data.tagData });\n\n    return { newTagName: data.newTagName, resultBool };\n}\n\nexport { projectEditeTag };\nexport type { TReturnTypeProjectEditeTag, TParametersProjectEditeTag };\n","import { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { DataComponentHeader } from \"0-shared/utils/classes/saveDataComponentHeader\";\nimport { saveDataComponentText } from \"0-shared/utils/classes/saveDataComponentText\";\nimport { saveDataComponentCode } from \"0-shared/utils/classes/saveDataComponentCode\";\nimport { saveDataComponentImage } from \"0-shared/utils/classes/saveDataComponentImage\";\nimport { saveDataComponentLink } from \"0-shared/utils/classes/saveDataComponentLink\";\nimport { saveDataComponentVideo } from \"0-shared/utils/classes/saveDataComponentVideo\";\nimport { DataComponentList } from \"0-shared/utils/classes/saveDataComponentList\";\nimport { saveDataComponentTable } from \"0-shared/utils/classes/saveDataComponentTable\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { IdGenerator } from \"0-shared/utils/idGenerator\";\nimport type { IDataTreeRootFolder, TAllComponents, TNoteBody } from \"0-shared/types/dataSave\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\n\ntype TReturnTypeAddNewComponentToNote = ReturnType<typeof addNewComponentToNote>;\ntype TParametersAddNewComponentToNote = Parameters<typeof addNewComponentToNote>;\n\n/**\n * Добавляет новый компонент в заметку\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которую нужно добавить компонент\n * @param componentType тип добавляемого компонента (заголовок, текст... короче TAllComponents)\n */\nasync function addNewComponentToNote(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentType: TAllComponents;\n    savedIdGenerator: string[];\n}) {\n    let resultBool = false;\n    let newIdGenerator = new IdGenerator(new Set(data.savedIdGenerator));\n    let updatedNote = getNodeById(data.rootFolder, data.noteId);\n\n    if (updatedNote && isDataTreeNote(updatedNote)) {\n        let component: TNoteBody | undefined;\n        switch (data.componentType) {\n            case \"header\":\n                component = new DataComponentHeader(newIdGenerator);\n                break;\n            case \"text\":\n                component = new saveDataComponentText(newIdGenerator);\n                break;\n            case \"code\":\n                component = new saveDataComponentCode(newIdGenerator);\n                break;\n            case \"image\":\n                component = new saveDataComponentImage(newIdGenerator);\n                break;\n            case \"link\":\n                component = new saveDataComponentLink(newIdGenerator);\n                break;\n            case \"video\":\n                component = new saveDataComponentVideo(newIdGenerator);\n                break;\n            case \"list\":\n                component = new DataComponentList(newIdGenerator);\n                break;\n            case \"table\":\n                component = new saveDataComponentTable(newIdGenerator);\n                break;\n            default:\n                component = undefined;\n                break;\n        }\n\n        if (component !== undefined) {\n            updatedNote.lastEditTime = Date.now();\n            resultBool = true;\n            updatedNote.body.push(component);\n            await setDataTreeDB({ value: data.rootFolder });\n        }\n    }\n\n    return { updatedNote, resultBool, newIdGenerator: newIdGenerator.getIdsArray() };\n}\n\nexport { addNewComponentToNote };\nexport type { TReturnTypeAddNewComponentToNote, TParametersAddNewComponentToNote };\n"],"names":["saveDataComponentTable","DataNode","constructor","idGenerator","super","component","value","desc","viewButtons","backlight","aligin","this","Object","setPrototypeOf","type","id","insIdGenerator","savedIdGenerator","instatnceIdGenerator","Error","generateId","DataTag","name","color","tag_name","IdGenerator","cache","_cache","Set","generator","result","i","_charMap","charAt","Math","floor","random","length","newId","has","add","console","log","concat","deleteId","delete","getIdsArray","Array","from","Proxy","undefined","set","target","prop","newValue","receiver","isDWorkerScope","error","window","dispatchEvent","CustomEvent","group","groupEnd","Reflect","self","toString","isDataTreeNote","node","isDataTreeFolder","isDataNoteBody","isFunctionData","isArray","argument_names","argument_values","isDelByIdData","rootNode","target_id","isDelCompInNote","rootFolder","componentID","isCloneFiltredTree","orig_obj","isUpdateNodeValue","noteId","componentId","isUpdNoteComponentsOrder","componentDragId","toComponentDragId","isUpdateNodeImage","newName","newSrc","isUpdateNodeTable","headers","rows","isTableValue","isUpdateNodeTableSettings","isUpdateNodeLink","isGetNodeById","args","isUpdateNoteComponentLinkSettings","isLabel","isBg","labelVal","isUpdateNoteComponentImageSettings","imageDesc","isDescHidden","isUpdateNoteComponentTextSettings","textBackground","textFormat","fontValue","lineBreak","isUpdateNoteComponentListSettings","listBg","isNumeric","isUpdateNoteComponentHeaderSettings","textAligin","headerSize","isUpdateNoteComponentCodeSettings","codeTheme","codeLanguage","isExpand","expandDesc","isUpdateNodeCompleted","isUpdateNodeName","isAddNodeTo","insertToId","newNode","isNodeMuveTo","muvedNodeID","muveToID","isNoteDeleteTag","targetNoteID","isTGlobalTag","tag","isNoteAddTag","isProjectDeleteTag","tagName","tagData","isGetParentNode","isProjectEditeTag","oldTagName","newTagName","newTagColor","isAddNewComponentToNote","componentType","DB_NAME","DB_VERSION","TEMP_DATA_KEY","def_onError","e","warn","def_onComplete","dispatchEventIndexedDBTreeUpdate","postMessage","dispatchEventIndexedDBTagsUpdate","dispatchEventIndexedDBImagesUpdate","dispatchEventIndexedDBTableUpdate","async","setDataTreeDB","_ref","onComplete","onError","callback","tx","openIndexedDB","transaction","onerror","oncomplete","store","put","done","setGlobalTagsDB","getGlobalTagsDB","arguments","get","delImageDB","key","keyItem","setImageDB","_ref2","getKey","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","transactionDoneMap","WeakMap","transformCache","reverseTransformCache","idbProxyTraps","IDBTransaction","objectStoreNames","objectStore","wrap","replaceTraps","wrapFunction","func","IDBCursor","prototype","advance","continue","continuePrimaryKey","includes","_len","_key","apply","unwrap","request","_len2","_key2","transformCachableValue","Promise","resolve","reject","unlisten","removeEventListener","complete","DOMException","addEventListener","cacheDonePromiseForTransaction","IDBDatabase","IDBObjectStore","IDBIndex","IDBRequest","promise","success","promisifyRequest","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","storeName","_len3","_key3","index","shift","all","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","isIteratorProp","Symbol","asyncIterator","db","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","then","catch","openDB","createObjectStore","keyPath","currentVersion","blockedVersion","setTableDB","getTableDB","delTableDB","_ref3","getAllNotes","data","allNotes","parser","children","item","push","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","o","defineProperty","enumerable","obj","hasOwnProperty","call","deleteById","parent","deletedNode","resultBool","newIdGenerator","finder","filter","child","innerIds","allIds","getAllIdsInNode","map","temp","getNodeById","find_id","body","cloneFiltredTree","filtres","_await$deepClone","clonedObj","internalFoldersId","deepClone","origNode","checkFilter","cloneNote","structuredClone","copyChildNode","innderFolder","note","resultName","resultTags","resultContent","tags","included","findTag","content","labelValue","tableData","JSON","stringify","getParentNode","nodeId","saveParent","finder_result","DataComponentHeader","saveDataComponentText","background","formatting","font","saveDataComponentCode","language","saveDataComponentImage","fileName","saveDataComponentLink","saveDataComponentVideo","DataComponentList","worker_postMessage","work_data","onmessage","func_data","Function","func_runer","funcExecutorCase","info","targetNote","lastEditTime","Date","now","updateNoteComponentImageSettings","noteID","deleteComponentInNote","updateNoteComponentLinkSettings","src","updateNodeImage","updateNodeLink","updateNodeTable","updateNodeTableSettings","updateNodeValue","dragComponentIndex","toComponentIndex","arr","fromIndex","toIndex","copyArr","moveElement","updNoteComponentsOrder","updateNoteComponentTextSettings","updateNoteComponentListSettings","updateNoteComponentHeaderSettings","updateNoteComponentCodeSettings","completed","updateNodeCompleted","targetNode","updateNodeName","addNodeTo","muvedNode","muvedNodeParent","moveToNode","element","nodeMuveTo","noteDeleteTag","allTags","prepareTags","tagItem","noteAddTag","projectDeleteTag","indexTagOldName","indexOf","projectEditeTag","updatedNote","addNewComponentToNote","taskRuner"],"sourceRoot":""}
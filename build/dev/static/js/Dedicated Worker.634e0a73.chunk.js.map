{"version":3,"file":"static/js/Dedicated Worker.634e0a73.chunk.js","mappings":"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","sources":["0-shared/utils/classes/saveDataTag.ts","0-shared/utils/idGenerator.ts","0-shared/utils/scopeChecks.ts","0-shared/utils/typeHelpers.ts","2-features/utils/appIndexedDBFynctions/appIndexedDBConst.ts","2-features/utils/appIndexedDBFynctions/appIndexedDBEvents.ts","2-features/utils/appIndexedDBFynctions/dataTreeDb.ts","2-features/utils/appIndexedDBFynctions/globalTagsFunctions.ts","2-features/utils/appIndexedDBFynctions/imageFunctions.ts","../node_modules/idb/build/index.js","2-features/utils/appIndexedDBFynctions/openDB.ts","2-features/utils/appIndexedDBFynctions/tableFunctions.ts","2-features/utils/saveDataParse.ts","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","2-features/utils/saveDataEditFunctions/deleteById.ts","2-features/utils/saveDataUtilsFunctions/getAllIdsInNode.ts","2-features/utils/saveDataParseFunctions/getNodeById.ts","0-shared/utils/note_find.ts","2-features/utils/saveDataParseFunctions/getParentNode.ts","0-shared/dedicatedWorker/dedicatedWorker.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentImageSettings.ts","2-features/utils/saveDataEditFunctions/deleteComponentInNote.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentLinkSettings.ts","2-features/utils/saveDataEditFunctions/updateNoteImage.ts","2-features/utils/saveDataEditFunctions/updateNodeLink.ts","2-features/utils/saveDataEditFunctions/updateNodeTable.ts","2-features/utils/saveDataEditFunctions/updateNodeTableSettings.ts","2-features/utils/saveDataEditFunctions/updateNoteValue.ts","2-features/utils/saveDataEditFunctions/updNoteComponentsOrder.ts","0-shared/utils/arrayFunctions.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentTextSettings.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentListSettings.ts","2-features/utils/saveDataEditFunctions/updateNoteComponentHeaderSettings.ts","2-features/utils/saveDataEditFunctions/componentCodeSettings.ts","2-features/utils/saveDataEditFunctions/updateNodeCompleted.ts","2-features/utils/saveDataEditFunctions/updateNodeName.ts","2-features/utils/saveDataEditFunctions/addNodeTo.ts","2-features/utils/saveDataEditFunctions/nodeMuveTo.ts","2-features/utils/saveDataEditFunctions/noteDeleteTag.ts","2-features/utils/saveDataEditFunctions/noteAddTag.ts","2-features/utils/saveDataEditFunctions/projectDeleteTag.ts","2-features/utils/saveDataEditFunctions/projectEditeTag.ts"],"sourcesContent":["import type { IGlobalTag, TTagColors } from \"0-shared/types/dataSave\";\n\n/**\n *  класс для создания новых тегов для IAllTags\n */\nclass DataTag implements IGlobalTag {\n    public tag_name: IGlobalTag[\"tag_name\"];\n    public color: IGlobalTag[\"color\"];\n\n    constructor(name: string, color: TTagColors) {\n        this.tag_name = name;\n        this.color = color;\n\n        Object.setPrototypeOf(this, null);\n    }\n}\n\nexport { DataTag };\n","import { isDWorkerScope } from \"./scopeChecks\";\n\n// генератор ID в виде строки из 16 символов\n\n/**\n * класс для генерации уникальных ID, используется для генерации уникальных идентификаторов для DataTemp в indexed db\n * @constructor_Param cache - Set(string) обьект с данными который будет использоватся в качестве кеша со всеми id\n */\nclass IdGenerator {\n    static _charMap: string = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n    private _cache: Set<string> = new Set();\n\n    constructor(cache: Set<string>) {\n        this._cache = cache;\n    }\n\n    public generateId(): string {\n        const generator = () => {\n            let result = \"\";\n            for (let i = 0; i < 16; i++) {\n                result += IdGenerator._charMap.charAt(Math.floor(Math.random() * IdGenerator._charMap.length));\n            }\n            return result;\n        };\n\n        let newId: string;\n\n        do {\n            newId = generator();\n        } while (this._cache.has(newId));\n\n        this._cache.add(newId);\n        //console.log(this.getIdsArray());\n        console.log(`idGenerator: add -> ${newId}`);\n        return newId;\n    }\n\n    public deleteId(id: string) {\n        if (this._cache.has(id)) {\n            this._cache.delete(id);\n            //console.log(this.getIdsArray());\n            console.log(`idGenerator: delete -> ${id}`);\n        }\n    }\n\n    public getIdsArray() {\n        return Array.from(this._cache);\n    }\n}\n\ntype TSavedIdGenerator = {\n    instatnceIdGenerator: IdGenerator | undefined;\n};\n\n/**\n * эту конструкцию будем использовать для сохранения экземпляра класса IdGenerator\n * и передачи ее в разные участки кода\n * @ изменение своиства instatnceIdGenerator будет приводить к событию appIdGeneratorNewInstance на window\n */\nconst savedIdGenerator: TSavedIdGenerator = new Proxy(\n    {\n        instatnceIdGenerator: undefined,\n    },\n    {\n        set(target, prop, newValue, receiver) {\n            if (isDWorkerScope()) {\n                console.error(\"set savedIdGenerator.instatnceIdGenerator can not be used in worker scope\");\n                throw new Error(\"set savedIdGenerator.instatnceIdGenerator can not be used in worker scope\");\n            }\n            if (prop === \"instatnceIdGenerator\") {\n                window.dispatchEvent(new CustomEvent(\"appIdGeneratorNewInstance\"));\n                console.group(\"savedIdGenerator: updated\");\n                console.log(newValue);\n                console.groupEnd();\n            }\n            return Reflect.set(target, prop, newValue, receiver);\n        },\n    }\n);\n\nexport { savedIdGenerator, IdGenerator };\nexport type { TSavedIdGenerator };\n","/**\n * Проверка на отсутствие глобольногоо обьекта window\n */\nfunction isNotWindow() {\n    return typeof window === \"undefined\";\n}\n\n/**\n * проверка что окружение self есть и оно пренадлежить Dedicated Worker\n */\nfunction isDWorkerScope() {\n    //eslint-disable-next-line\n    return typeof self === \"object\" && self.toString() === \"[object DedicatedWorkerGlobalScope]\";\n}\n\nexport { isNotWindow, isDWorkerScope };\n","import { ForwardRefRenderFunction } from \"react\";\nimport type { IDataTreeNote, IDataTreeFolder, TNoteBody, IDataSave, IGlobalTag } from \"0-shared/types/dataSave\";\nimport type {\n    TMessageDataType,\n    TMessageDelById,\n    TMessageDelCompInNote,\n    TMessageCloneFiltredTreeOnWorker,\n    TMessageUpdateNodeValueOnWorker,\n    TMessageUpdNoteComponentsOrderOnWorker,\n    TMessageUpdateNodeImageOnWorker,\n    TMessageUpdateNodeTableOnWorker,\n    TMessageUpdateNodeTableSettingsOnWorker,\n    TMessageUpdateNodeLinkOnWorker,\n    TMessageGetNodeByIdOnWorker,\n    TMessageUpdateNoteComponentLinkSettingsOnWorker,\n    TMessageUpdateNoteComponentImageSettingsOnWorker,\n    TMessageUpdateNoteComponentTextSettingsOnWorker,\n    TMessageUpdateNoteComponentListSettingsOnWorker,\n    TMessageUpdateNoteComponentHeaderSettingsOnWorker,\n    TMessageUpdateNoteComponentCodeSettingsOnWorker,\n    TMessageUpdateNodeCompletedOnWorker,\n    TMessageUpdateNodeNameOnWorker,\n    TMessageAddNodeToOnWorker,\n    TMessageNodeMuveToOnWorker,\n    TMessageNoteDeleteTagOnWorker,\n    TMessageNoteAddTagOnWorker,\n    TMessageProjectDeleteTagOnWorker,\n    TMessageGetParentNodeOnWorker,\n    TMessageProjectEditeTagOnWorker,\n} from \"0-shared/dedicatedWorker/workerTypes\";\nimport type { TTableValue } from \"0-shared/types/dataSave\";\n\n/**\n *  убирает своиство readonly у полей массива или обьекта\n */\ntype RemoveReadonly<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n/**\n * вычисляет пропсы компонента\n * @tparam T - тип компонента\n */\ntype GetProps<T> = T extends React.ComponentType<infer Props> ? Props : unknown;\n\n/**\n * типизирует параметр ref в компоненте, если используется forwardRef\n * @tparam T - тип элемента на который перенаправляется ref (например HTMLInputElement)\n */\ntype Ref<T> = Parameters<ForwardRefRenderFunction<T>>[1];\n\n/**\n * преобразует массив от Parameters<> в обьект, где, K будет массивом ключей\n * @tparam T - массив возвращенный дженериком Parameters\n * @tparam K - массив ключей, которые будут присвоины типам с соответствующими индексами в T\n */\ntype TupleToObject<T extends any[], K extends { [I in keyof T]: PropertyKey }> = {\n    [I in keyof T as I extends keyof any[] ? never : K[I]]: T[I];\n};\n\nfunction isTGlobalTag(value: any): value is IGlobalTag {\n    if (typeof value !== \"object\") return false;\n    if (!(\"tag_name\" in value) || (\"tag_name\" in value && typeof value.tag_name !== \"string\")) return false;\n    if (!(\"color\" in value) || (\"color\" in value && typeof value.color !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу IDataTreeNote\n * @param node\n * @returns boolean\n */\nfunction isDataTreeNote(node: any): node is IDataTreeNote {\n    if (typeof node !== \"object\") return false;\n    if (!(\"type\" in node)) return false;\n    return node.type === \"note\";\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу IDataTreeFolder\n * @param node\n * @returns boolean\n */\nfunction isDataTreeFolder(node: any): node is IDataTreeFolder {\n    if (typeof node !== \"object\") return false;\n    if (!(\"type\" in node)) return false;\n    return node.type === \"folder\";\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TTableValue\n * @returns boolean\n */\nfunction isTableValue(value: any): value is TTableValue {\n    if (typeof value !== \"object\") return false;\n    if (!(\"headers\" in value) || (\"headers\" in value && !Array.isArray(value.headers))) return false;\n    if (!(\"rows\" in value) || (\"rows\" in value && !Array.isArray(value.rows))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TNoteBody\n * @param node\n * @returns boolean\n */\nfunction isDataNoteBody(node: any): node is TNoteBody {\n    if (typeof node !== \"object\") return false;\n    if (!(\"type\" in node)) return false;\n    return node.type === \"component\";\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу IDataSave\n * @param node\n * @returns boolean\n */\nfunction isDataSave(node: any): node is IDataSave {\n    if (typeof node !== \"object\") return false;\n    if (!(\"db_type\" in node)) return false;\n    if (!(\"data_tree\" in node)) return false;\n    if (!(\"global_tags\" in node)) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageDataType dedicated воркера\n */\nfunction isFunctionData(value: any): value is TMessageDataType {\n    if (typeof value !== \"object\") return false;\n    if (!(\"argument_names\" in value)) return false;\n    if (!(\"argument_values\" in value)) return false;\n    if (!(\"func_data\" in value)) return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"function executor\")) return false;\n    if (!Array.isArray(value.argument_names)) return false;\n    if (!Array.isArray(value.argument_values)) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageDelById dedicated воркера\n */\nfunction isDelByIdData(value: any): value is TMessageDelById {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"delete by id\")) return false;\n    if (!(\"rootNode\" in value) || (\"rootNode\" in value && !isDataTreeFolder(value.rootNode))) return false;\n    if (!(\"target_id\" in value) || (\"target_id\" in value && typeof value.target_id !== \"string\")) return false;\n    if (!(\"savedIdGenerator\" in value) || (\"savedIdGenerator\" in value && !Array.isArray(value.savedIdGenerator))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageDelCompInNote dedicated воркера\n */\nfunction isDelCompInNote(value: any): value is TMessageDelCompInNote {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"delete component in note\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"componentID\" in value) || (\"componentID\" in value && typeof value.componentID !== \"string\")) return false;\n    if (!(\"savedIdGenerator\" in value) || (\"savedIdGenerator\" in value && !Array.isArray(value.savedIdGenerator))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageDelCompInNote dedicated воркера\n */\nfunction isCloneFiltredTree(value: any): value is TMessageCloneFiltredTreeOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"clone filtred tree\")) return false;\n    if (!(\"orig_obj\" in value) || (\"orig_obj\" in value && !isDataTreeFolder(value.orig_obj))) return false;\n    if (!(\"filtres\" in value)) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeValueOnWorker dedicated воркера\n */\nfunction isUpdateNodeValue(value: any): value is TMessageUpdateNodeValueOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node value\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"newValue\" in value) || (\"newValue\" in value && typeof value.newValue !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdNoteComponentsOrderOnWorker dedicated воркера\n */\nfunction isUpdNoteComponentsOrder(value: any): value is TMessageUpdNoteComponentsOrderOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note components order\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentDragId\" in value) || (\"componentDragId\" in value && typeof value.componentDragId !== \"string\")) return false;\n    if (!(\"toComponentDragId\" in value) || (\"toComponentDragId\" in value && typeof value.toComponentDragId !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdNoteComponentsOrderOnWorker dedicated воркера\n */\nfunction isUpdateNodeImage(value: any): value is TMessageUpdateNodeImageOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node image\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"newName\" in value) || (\"newName\" in value && typeof value.newName !== \"string\")) return false;\n    if (!(\"newSrc\" in value) || (\"newSrc\" in value && typeof value.newSrc !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeTableOnWorker dedicated воркера\n */\nfunction isUpdateNodeTable(value: any): value is TMessageUpdateNodeTableOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node table\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"newValue\" in value) || (\"newValue\" in value && !isTableValue(value.newValue))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeTableSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNodeTableSettings(value: any): value is TMessageUpdateNodeTableSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node table settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"backlight\" in value) || (\"backlight\" in value && typeof value.backlight !== \"boolean\")) return false;\n    if (!(\"desc\" in value) || (\"desc\" in value && typeof value.desc !== \"string\")) return false;\n    if (!(\"viewButtons\" in value) || (\"viewButtons\" in value && typeof value.viewButtons !== \"boolean\")) return false;\n    if (!(\"aligin\" in value) || (\"aligin\" in value && typeof value.aligin !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeLinkOnWorker dedicated воркера\n */\nfunction isUpdateNodeLink(value: any): value is TMessageUpdateNodeLinkOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node link\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"target\" in value) || (\"target\" in value && typeof value.target !== \"string\")) return false;\n    if (!(\"value\" in value) || (\"value\" in value && typeof value.value !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageGetNodeByIdOnWorker dedicated воркера\n */\nfunction isGetNodeById(value: any): value is TMessageGetNodeByIdOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"get node by id\")) return false;\n    if (!(\"args\" in value) || (\"args\" in value && !Array.isArray(value.args))) return false;\n    if (value.args.length < 2) return false;\n    if (!isDataTreeFolder(value.args[0])) return false;\n    if (typeof value.args[1] !== \"string\") return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentLinkSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentLinkSettings(value: any): value is TMessageUpdateNoteComponentLinkSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update Note component link settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"isLabel\" in value) || (\"isLabel\" in value && typeof value.isLabel !== \"boolean\")) return false;\n    if (!(\"isBg\" in value) || (\"isBg\" in value && typeof value.isBg !== \"boolean\")) return false;\n    if (!(\"labelVal\" in value) || (\"labelVal\" in value && typeof value.labelVal !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentImageSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentImageSettings(value: any): value is TMessageUpdateNoteComponentImageSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component image settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"imageDesc\" in value) || (\"imageDesc\" in value && typeof value.imageDesc !== \"string\")) return false;\n    if (!(\"isDescHidden\" in value) || (\"isDescHidden\" in value && typeof value.isDescHidden !== \"boolean\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentTextSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentTextSettings(value: any): value is TMessageUpdateNoteComponentTextSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component text settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"textBackground\" in value) || (\"textBackground\" in value && typeof value.textBackground !== \"boolean\")) return false;\n    if (!(\"textFormat\" in value) || (\"textFormat\" in value && typeof value.textFormat !== \"boolean\")) return false;\n    if (!(\"fontValue\" in value) || (\"fontValue\" in value && typeof value.fontValue !== \"string\")) return false;\n    if (!(\"lineBreak\" in value) || (\"lineBreak\" in value && typeof value.lineBreak !== \"boolean\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentListSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentListSettings(value: any): value is TMessageUpdateNoteComponentListSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component list settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"listBg\" in value) || (\"listBg\" in value && typeof value.listBg !== \"boolean\")) return false;\n    if (!(\"isNumeric\" in value) || (\"isNumeric\" in value && typeof value.isNumeric !== \"boolean\")) return false;\n    if (!(\"aligin\" in value) || (\"aligin\" in value && typeof value.aligin !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentHeaderSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentHeaderSettings(value: any): value is TMessageUpdateNoteComponentHeaderSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component header settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"componentId\" in value) || (\"componentId\" in value && typeof value.componentId !== \"string\")) return false;\n    if (!(\"textAligin\" in value) || (\"textAligin\" in value && typeof value.textAligin !== \"string\")) return false;\n    if (!(\"headerSize\" in value) || (\"headerSize\" in value && typeof value.headerSize !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNoteComponentCodeSettingsOnWorker dedicated воркера\n */\nfunction isUpdateNoteComponentCodeSettings(value: any): value is TMessageUpdateNoteComponentCodeSettingsOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update note component code settings\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"codeTheme\" in value) || (\"codeTheme\" in value && typeof value.codeTheme !== \"string\")) return false;\n    if (!(\"codeLanguage\" in value) || (\"codeLanguage\" in value && typeof value.codeLanguage !== \"string\")) return false;\n    if (!(\"isExpand\" in value) || (\"isExpand\" in value && typeof value.isExpand !== \"boolean\")) return false;\n    if (!(\"expandDesc\" in value) || (\"expandDesc\" in value && typeof value.expandDesc !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeCompletedOnWorker dedicated воркера\n */\nfunction isUpdateNodeCompleted(value: any): value is TMessageUpdateNodeCompletedOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node completed\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"noteId\" in value) || (\"noteId\" in value && typeof value.noteId !== \"string\")) return false;\n    if (!(\"newValue\" in value) || (\"newValue\" in value && typeof value.newValue !== \"boolean\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageUpdateNodeNameOnWorker dedicated воркера\n */\nfunction isUpdateNodeName(value: any): value is TMessageUpdateNodeNameOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"update node name\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"target_id\" in value) || (\"target_id\" in value && typeof value.target_id !== \"string\")) return false;\n    if (!(\"newName\" in value) || (\"newName\" in value && typeof value.newName !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageAddNodeToOnWorker dedicated воркера\n */\nfunction isAddNodeTo(value: any): value is TMessageAddNodeToOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"add node to\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"insertToId\" in value) || (\"insertToId\" in value && typeof value.insertToId !== \"string\")) return false;\n    if (!(\"newNode\" in value)) return false;\n    if (\"newNode\" in value) {\n        if (!isDataTreeNote(value.newNode) && !isDataTreeFolder(value.newNode) && !isDataNoteBody(value.newNode)) return false;\n    }\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageNodeMuveToOnWorker dedicated воркера\n */\nfunction isNodeMuveTo(value: any): value is TMessageNodeMuveToOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"node move to\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"muvedNodeID\" in value) || (\"muvedNodeID\" in value && typeof value.muvedNodeID !== \"string\")) return false;\n    if (!(\"muveToID\" in value) || (\"muveToID\" in value && typeof value.muveToID !== \"string\")) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageNoteDeleteTagOnWorker dedicated воркера\n */\nfunction isNoteDeleteTag(value: any): value is TMessageNoteDeleteTagOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"note delete tag\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"targetNoteID\" in value) || (\"targetNoteID\" in value && typeof value.targetNoteID !== \"string\")) return false;\n    if (!(\"tag\" in value) || (\"tag\" in value && !isTGlobalTag(value.tag))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageNoteAddTagOnWorker dedicated воркера\n */\nfunction isNoteAddTag(value: any): value is TMessageNoteAddTagOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"note add tag\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"targetNoteID\" in value) || (\"targetNoteID\" in value && typeof value.targetNoteID !== \"string\")) return false;\n    if (!(\"tag\" in value) || (\"tag\" in value && !(typeof value.tag === \"string\" || Array.isArray(value.tag)))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageProjectDeleteTagOnWorker dedicated воркера\n */\nfunction isProjectDeleteTag(value: any): value is TMessageProjectDeleteTagOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"project delete tag\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"tagName\" in value) || (\"tagName\" in value && typeof value.tagName !== \"string\")) return false;\n    if (!(\"tagData\" in value) || (\"tagData\" in value && !(typeof value.tagData === \"object\"))) return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageGetParentNodeOnWorker dedicated воркера\n */\nfunction isGetParentNode(value: any): value is TMessageGetParentNodeOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"get parent node\")) return false;\n    if (!(\"args\" in value) || (\"args\" in value && !Array.isArray(value.args))) return false;\n    if (value.args.length < 2) return false;\n    if (!isDataTreeFolder(value.args[0])) return false;\n    if (typeof value.args[1] !== \"string\") return false;\n    return true;\n}\n\n/**\n * проверяет чтобы сущьность пренадлежала к типу TMessageProjectEditeTagOnWorker dedicated воркера\n */\nfunction isProjectEditeTag(value: any): value is TMessageProjectEditeTagOnWorker {\n    if (typeof value !== \"object\") return false;\n    if (!(\"type\" in value) || (\"type\" in value && value.type !== \"project edite tag\")) return false;\n    if (!(\"rootFolder\" in value) || (\"rootFolder\" in value && !isDataTreeFolder(value.rootFolder))) return false;\n    if (!(\"tagData\" in value) || (\"tagData\" in value && !(typeof value.tagData === \"object\"))) return false;\n    if (!(\"oldTagName\" in value) || (\"oldTagName\" in value && typeof value.oldTagName !== \"string\")) return false;\n    if (!(\"newTagName\" in value) || (\"newTagName\" in value && typeof value.newTagName !== \"string\")) return false;\n    if (!(\"newTagColor\" in value) || (\"newTagColor\" in value && typeof value.newTagColor !== \"string\")) return false;\n    return true;\n}\n\nexport {\n    isDataTreeNote,\n    isDataTreeFolder,\n    isDataNoteBody,\n    isDataSave,\n    isFunctionData,\n    isDelByIdData,\n    isDelCompInNote,\n    isCloneFiltredTree,\n    isUpdateNodeValue,\n    isUpdNoteComponentsOrder,\n    isUpdateNodeImage,\n    isTableValue,\n    isUpdateNodeTable,\n    isUpdateNodeTableSettings,\n    isUpdateNodeLink,\n    isGetNodeById,\n    isUpdateNoteComponentLinkSettings,\n    isUpdateNoteComponentImageSettings,\n    isUpdateNoteComponentTextSettings,\n    isUpdateNoteComponentListSettings,\n    isUpdateNoteComponentHeaderSettings,\n    isUpdateNoteComponentCodeSettings,\n    isUpdateNodeCompleted,\n    isUpdateNodeName,\n    isAddNodeTo,\n    isNodeMuveTo,\n    isTGlobalTag,\n    isNoteDeleteTag,\n    isNoteAddTag,\n    isProjectDeleteTag,\n    isGetParentNode,\n    isProjectEditeTag,\n};\nexport type { GetProps, Ref, RemoveReadonly, TupleToObject };\n","/**\n * различные константы и дефолтные значения как либо связанные с indexed db\n */\n\n/**\n * ключи хранилищь в indexed db, в которых могт лежать данные приложения заметок\n */\nconst tempStoreData = [\"db_type\", \"data_tree\", \"global_tags\", \"data_images\", \"data_tables\"] as const;\n\nconst DB_NAME = \"app_note_master_db_data\";\nconst DB_VERSION = 3;\nconst TEMP_DATA_KEY = \"0\";\n\nfunction def_onError(e: Event) {\n    console.warn(e);\n}\n\nfunction def_onComplete(e: Event) {\n    //    console.log(e);\n}\n\nexport { tempStoreData, DB_NAME, DB_VERSION, TEMP_DATA_KEY, def_onError, def_onComplete };\n","import { isDWorkerScope } from \"0-shared/utils/scopeChecks\";\n\n/**\n * генерация событий на обьекте window при изменениях в indexed db (myDB)\n */\n\nfunction dispatchEventIndexedDBTreeUpdate() {\n    if (!isDWorkerScope()) {\n        window.dispatchEvent(new CustomEvent(\"appIndexedDBTreeUpdate\"));\n    } else {\n        //eslint-disable-next-line\n        self.postMessage(\"worker generate event: appIndexedDBTreeUpdate\");\n    }\n}\n\nfunction dispatchEventIndexedDBTagsUpdate() {\n    if (!isDWorkerScope()) {\n        window.dispatchEvent(new CustomEvent(\"appIndexedDBTagsUpdate\"));\n    } else {\n        //eslint-disable-next-line\n        self.postMessage(\"worker generate event: appIndexedDBTagsUpdate\");\n    }\n}\n\nfunction dispatchEventIndexedDBImagesUpdate() {\n    if (!isDWorkerScope()) {\n        window.dispatchEvent(new CustomEvent(\"appIndexedDBImagesUpdate\"));\n    } else {\n        //eslint-disable-next-line\n        self.postMessage(\"worker generate event: appIndexedDBImagesUpdate\");\n    }\n}\n\nfunction dispatchEventIndexedDBTableUpdate() {\n    if (!isDWorkerScope()) {\n        window.dispatchEvent(new CustomEvent(\"appIndexedDBTablesUpdate\"));\n    } else {\n        //eslint-disable-next-line\n        self.postMessage(\"worker generate event: appIndexedDBTablesUpdate\");\n    }\n}\n\nexport {\n    dispatchEventIndexedDBTreeUpdate,\n    dispatchEventIndexedDBTagsUpdate,\n    dispatchEventIndexedDBImagesUpdate,\n    dispatchEventIndexedDBTableUpdate,\n};\n","import { def_onComplete, def_onError, TEMP_DATA_KEY } from \"./appIndexedDBConst\";\nimport { openIndexedDB } from \"./openDB\";\nimport { dispatchEventIndexedDBTreeUpdate } from \"./appIndexedDBEvents\";\nimport type { MyDB, TSetDataEntity, TGetDataEntity } from \"./appIndexedDBTypes\";\n\n/**\n * Записывает новое значение вместо обьекта data_tree в indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(value): вызывается после применения изменений\n * @property value: новое значение\n */\nasync function setDataTreeDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    value,\n}: TSetDataEntity<MyDB[\"data_tree\"][\"value\"]>) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tree\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    tx.store.put(value, TEMP_DATA_KEY);\n    await tx.done;\n    callback && callback(value);\n    dispatchEventIndexedDBTreeUpdate();\n    return value;\n}\n\n/**\n * возвращает обьект data_tree из indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(data_tree | undefined): вызывается после поиска\n * @returns Promise<data_tree | undefined>\n */\nasync function getDataTreeDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n}: TGetDataEntity<MyDB[\"data_tree\"][\"value\"] | undefined> = {}) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tree\", \"readonly\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    let value = await tx.store.get(TEMP_DATA_KEY);\n    await tx.done;\n    callback && callback(value);\n    return value;\n}\n\nexport { getDataTreeDB, setDataTreeDB };\n","import { def_onComplete, def_onError, TEMP_DATA_KEY } from \"./appIndexedDBConst\";\nimport { openIndexedDB } from \"./openDB\";\nimport { dispatchEventIndexedDBTagsUpdate } from \"./appIndexedDBEvents\";\nimport type { MyDB, TSetDataEntity, TGetDataEntity } from \"./appIndexedDBTypes\";\n\n/**\n * Записывает новое значение вместо обьекта global_tags в indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(value): вызывается после применения изменений\n * @property value: новое значение\n */\nasync function setGlobalTagsDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    value,\n}: TSetDataEntity<MyDB[\"global_tags\"][\"value\"]>) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"global_tags\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    tx.store.put(value, TEMP_DATA_KEY);\n    await tx.done;\n    callback && callback(value);\n    dispatchEventIndexedDBTagsUpdate();\n    return value;\n}\n\n/**\n * возвращает обьект global_tags из indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @returns Promise<global_tags | undefined>\n */\nasync function getGlobalTagsDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n}: TGetDataEntity<MyDB[\"global_tags\"][\"value\"] | undefined> = {}) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"global_tags\", \"readonly\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    let value = await tx.store.get(TEMP_DATA_KEY);\n    await tx.done;\n    callback && callback(value);\n    return value;\n}\n\nexport { setGlobalTagsDB, getGlobalTagsDB };\n","import { def_onComplete, def_onError } from \"./appIndexedDBConst\";\nimport { dispatchEventIndexedDBImagesUpdate } from \"./appIndexedDBEvents\";\nimport { openIndexedDB } from \"./openDB\";\nimport type { TGetKeyDataEntity, MyDB, TSetKeyDataEntity } from \"./appIndexedDBTypes\";\n\n/**\n * удаляет элемент из data_images по ключу, или много элементов по массиву ключей\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @property key: ключь (ID) элемента который нужно получить\n * @returns Promise<global_tags | undefined>\n */\nasync function delImageDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    key,\n}: TGetKeyDataEntity<boolean | undefined, string | string[]>) {\n    if (!key) throw new Error(\"the key is required\");\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_images\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    if (Array.isArray(key)) {\n        for await (let keyItem of key) {\n            tx.store.delete(keyItem);\n        }\n    } else {\n        await tx.store.delete(key);\n    }\n    await tx.done;\n    callback && callback(true);\n    dispatchEventIndexedDBImagesUpdate();\n    return true;\n}\n\n/**\n * Записывает новое значение в хранилище data_images в indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(value): вызывается после применения изменений\n * @property value: новое значение\n */\nasync function setImageDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    value,\n    key,\n}: TSetKeyDataEntity<MyDB[\"data_images\"][\"value\"]>) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_images\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n\n    const hasItemInDB = await tx.store.getKey(key);\n    if (hasItemInDB) {\n        await tx.store.delete(key);\n    }\n\n    await tx.store.add(value);\n    await tx.done;\n    callback && callback(value);\n    dispatchEventIndexedDBImagesUpdate();\n    return value;\n}\n\n/**\n * возвращает элемент из data_images из indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @property key: ключь (ID) элемента который нужно получить\n * @returns Promise<global_tags | undefined>\n */\nasync function getImageDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    key,\n}: TGetKeyDataEntity<MyDB[\"data_images\"][\"value\"] | undefined>) {\n    if (!key) throw new Error(\"key \");\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_images\", \"readonly\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    let value = await tx.store.get(key);\n    await tx.done;\n    callback && callback(value);\n    return value;\n}\n\nexport { delImageDB, getImageDB, setImageDB };\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","import { openDB } from \"idb\";\nimport { DB_NAME, DB_VERSION } from \"./appIndexedDBConst\";\nimport type { MyDB } from \"./appIndexedDBTypes\";\n\n/**\n * async функция, возвращает обьект indexed db\n * @returns\n */\nasync function openIndexedDB() {\n    const db = await openDB<MyDB>(DB_NAME, DB_VERSION, {\n        upgrade(db, oldVersion, newVersion, transaction, event) {\n            if (oldVersion === newVersion) {\n                const savedDataDB = db.createObjectStore(\"savedData\");\n                const dbType = db.createObjectStore(\"db_type\");\n                const data_tree = db.createObjectStore(\"data_tree\");\n                const global_tags = db.createObjectStore(\"global_tags\");\n                const data_images = db.createObjectStore(\"data_images\", {\n                    keyPath: \"id\",\n                });\n                const data_tables = db.createObjectStore(\"data_tables\", {\n                    keyPath: \"id\",\n                });\n            } else {\n                //TODO: при изменении схемы бд, нужно менять версию бд, после чего нежно тут реализовать обновление схемы бд, для новой версии.\n                let currentVersion = oldVersion;\n                debugger;\n                do {\n                    switch (currentVersion + 1) {\n                        case 1:\n                            const savedDataDB = db.createObjectStore(\"savedData\");\n                            const dbType = db.createObjectStore(\"db_type\");\n                            const data_tree = db.createObjectStore(\"data_tree\");\n                            const global_tags = db.createObjectStore(\"global_tags\");\n                            break;\n                        case 2:\n                            const data_images = db.createObjectStore(\"data_images\", {\n                                keyPath: \"id\",\n                            });\n                            break;\n                        case 3:\n                            const data_tables = db.createObjectStore(\"data_tables\", {\n                                keyPath: \"id\",\n                            });\n                            break;\n                        default:\n                            throw new Error(\n                                \"A new version of the database has been detected, but the logic for updating the schema has not been implemented.\"\n                            );\n                    }\n                    currentVersion++;\n                } while (currentVersion < (newVersion ?? 1));\n            }\n        },\n        blocked(currentVersion, blockedVersion, event) {},\n        blocking(currentVersion, blockedVersion, event) {},\n        terminated() {},\n    });\n\n    return db;\n}\n\nexport { openIndexedDB };\n","import { def_onComplete, def_onError } from \"./appIndexedDBConst\";\nimport { dispatchEventIndexedDBTableUpdate } from \"./appIndexedDBEvents\";\nimport { openIndexedDB } from \"./openDB\";\nimport type { MyDB, TSetKeyDataEntity, TGetKeyDataEntity } from \"./appIndexedDBTypes\";\n\n/**\n * Записывает новое значение в хранилище data_table в indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(value): вызывается после применения изменений\n * @property value: новое значение\n */\nasync function setTableDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    value,\n    key,\n}: TSetKeyDataEntity<MyDB[\"data_tables\"][\"value\"]>) {\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tables\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n\n    const hasItemInDB = await tx.store.getKey(key);\n    if (hasItemInDB) {\n        await tx.store.delete(key);\n    }\n\n    await tx.store.add(value);\n    await tx.done;\n    callback && callback(value);\n    dispatchEventIndexedDBTableUpdate();\n    return value;\n}\n\n/**\n * возвращает элемент из data_table из indexed db\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @property key: ключь (ID) элемента который нужно получить\n * @returns Promise<global_tags | undefined>\n */\nasync function getTableDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    key,\n}: TGetKeyDataEntity<MyDB[\"data_tables\"][\"value\"] | undefined>) {\n    if (!key) throw new Error(\"key \");\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tables\", \"readonly\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    let value = await tx.store.get(key);\n    await tx.done;\n    callback && callback(value);\n    return value;\n}\n\n/**\n * удаляет элемент из data_table по ключу, или много элементов по массиву ключей\n * @property onComplete: определение колбека db.transaction,\n * @property onError: определение колбека db.transaction,\n * @property callback(global_tags | undefined): вызывается после поиска\n * @property key: ключь (ID) элемента который нужно получить\n * @returns Promise<global_tags | undefined>\n */\nasync function delTableDB({\n    onComplete = def_onComplete,\n    onError = def_onError,\n    callback,\n    key,\n}: TGetKeyDataEntity<boolean | undefined, string | string[]>) {\n    if (!key) throw new Error(\"the key is required\");\n    const db = await openIndexedDB();\n    const tx = db.transaction(\"data_tables\", \"readwrite\");\n    tx.onerror = onError;\n    tx.oncomplete = onComplete;\n    if (Array.isArray(key)) {\n        for await (let keyItem of key) {\n            tx.store.delete(keyItem);\n        }\n    } else {\n        await tx.store.delete(key);\n    }\n    await tx.done;\n    callback && callback(true);\n    dispatchEventIndexedDBTableUpdate();\n    return true;\n}\n\nexport { delTableDB, setTableDB, getTableDB };\n","import { isDataTreeFolder, isDataTreeNote, isDataSave } from \"0-shared/utils/typeHelpers\";\nimport { nodeWithoutChildren } from \"./saveDataUtils\";\nimport type { IDataTreeFolder, IDataTreeNote, TNoteBody, IDataTreeRootFolder, IDataSave } from \"0-shared/types/dataSave\";\n\n// функции для поиска разлиных элементов в tempData в indexedDB\n\n/**\n * сбор всех ID из IDataTreeRootFolder\n * @param data обьект сохранения IDataTreeRootFolder\n * @returns\n */\nfunction getAllIds(data: IDataTreeRootFolder | IDataSave) {\n    const allIds = new Set<string>();\n\n    const parser = (node: IDataTreeFolder | IDataTreeNote | TNoteBody) => {\n        if (allIds.has(node.id)) throw new Error(\"Duplicate id in tempData\");\n        allIds.add(node.id);\n\n        if (isDataTreeFolder(node) && node.children) {\n            for (let item of node.children) {\n                parser(item);\n            }\n        }\n\n        if (isDataTreeNote(node)) {\n            for (let item of node.body) {\n                parser(item);\n            }\n        }\n    };\n\n    parser(isDataSave(data) ? data.data_tree : data);\n\n    return allIds;\n}\n\n/**\n * возвращает все папки внутри data, на любой вложенности\n * @param data обьект сохранения IDataTreeRootFolder\n * @returns\n */\nfunction getAllFolders(data: IDataTreeRootFolder) {\n    const allFolders: IDataTreeFolder[] = [];\n\n    const parser = (node: IDataTreeFolder | IDataTreeNote | TNoteBody) => {\n        if (isDataTreeFolder(node)) {\n            allFolders.push(nodeWithoutChildren(node) as IDataTreeFolder);\n\n            if (!node.children) return;\n            for (let item of node.children) {\n                parser(item);\n            }\n        }\n    };\n\n    parser(data);\n\n    return allFolders;\n}\n\n/**\n * возвращает все заметки внутри data, на любой вложенности\n * @param data обьект сохранения IDataTreeRootFolder\n * @returns\n */\nfunction getAllNotes(data: IDataTreeRootFolder) {\n    const allNotes: IDataTreeNote[] = [];\n\n    const parser = (node: IDataTreeFolder | IDataTreeNote | TNoteBody) => {\n        if (isDataTreeFolder(node)) {\n            if (!node.children) return;\n            for (let item of node.children) {\n                parser(item);\n            }\n        }\n\n        if (isDataTreeNote(node)) {\n            allNotes.push(node);\n        }\n    };\n\n    parser(data);\n\n    return allNotes;\n}\n\n/**\n * ищет родительскую папку для ноды\n * @param rootNode обект типа IDataTreeRootFolder | TchildrenType\n * @param nodeId id ноды для которой нужно отыскать родителя\n */\nfunction getParentFolder(rootNode: IDataTreeFolder, nodeId: string): IDataTreeNote | IDataTreeFolder | TNoteBody | null | undefined {\n    type TTreeElement = IDataTreeNote | IDataTreeFolder | TNoteBody;\n\n    let parent: IDataTreeNote | IDataTreeFolder | IDataTreeRootFolder | TNoteBody;\n\n    parent = rootNode;\n    let result: TTreeElement | null | undefined;\n\n    const finder = (node: TTreeElement): TTreeElement | null | undefined => {\n        if (node.id === nodeId) {\n            if (node.id === parent.id) return undefined;\n            return parent as TTreeElement;\n        }\n\n        if (isDataTreeFolder(node)) {\n            if (node.children) {\n                let saveParent = parent;\n                parent = node;\n                for (let child of node.children) {\n                    let finder_result = finder(child);\n                    if (finder_result === undefined) return null;\n                    if (finder_result) return finder_result;\n                }\n                parent = saveParent;\n            }\n            return null;\n        }\n\n        return null;\n    };\n\n    result = finder(parent);\n\n    return result;\n}\n\nexport { getAllIds, getAllFolders, getAllNotes, getParentFolder };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { IdGenerator } from \"0-shared/utils/idGenerator\";\nimport { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getAllIdsInNode } from \"../saveDataUtilsFunctions/getAllIdsInNode\";\nimport { delImageDB } from \"../appIndexedDBFynctions/imageFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { delTableDB } from \"../appIndexedDBFynctions/tableFunctions\";\nimport type { IDataTreeRootFolder, IDataTreeFolder, TchildrenType } from \"0-shared/types/dataSave\";\n\n/**\n * удаляет ноду типа TchildrenType по id из tempData в indexedDB\n * @param rootNode - обьект сохранения IDataTreeRootFolder\n * @param target_id - id ноды которую нужно удалить\n * @param savedIdGenerator - результат вызова savedIdGenerator.instatnceIdGenerator.getIdsArray()\n */\ntype TReturnTypeDeleteById = ReturnType<typeof deleteById>;\ntype TParametersDeleteById = Parameters<typeof deleteById>;\n\nasync function deleteById(data: { rootNode: IDataTreeRootFolder; target_id: string; savedIdGenerator: string[] }) {\n    let parent: IDataTreeFolder;\n    let deletedNode: TchildrenType | undefined;\n    let resultBool = false;\n    let newIdGenerator = new IdGenerator(new Set(data.savedIdGenerator));\n\n    const finder = (node: TchildrenType) => {\n        if (node.id === data.target_id && node.id !== \"root\") {\n            parent.children = parent.children!.filter((child) => {\n                if (child.id === data.target_id) {\n                    if (isDataTreeFolder(child) || isDataTreeNote(child)) {\n                        const innerIds = getAllIdsInNode(child);\n                        delImageDB({ key: innerIds });\n                        delTableDB({ key: innerIds });\n                        innerIds.map((id) => {\n                            newIdGenerator.deleteId(id);\n                        });\n                    }\n                    newIdGenerator.deleteId(data.target_id);\n                    deletedNode = child;\n                    return false;\n                }\n                return true;\n            });\n            resultBool = true;\n            return true;\n        }\n\n        if (isDataTreeFolder(node)) {\n            if (node.children) {\n                let temp = parent;\n                parent = node;\n                for (let child of node.children) {\n                    let result = finder(child);\n                    if (result) return true;\n                }\n                parent = temp;\n            }\n        }\n    };\n\n    parent = data.rootNode;\n    let result = finder(data.rootNode);\n    if (!result) throw new Error(`node not found`);\n    await setDataTreeDB({ value: data.rootNode });\n    return { deletedNode, resultBool, newIdGenerator: newIdGenerator.getIdsArray() };\n}\n\nexport { deleteById };\nexport type { TReturnTypeDeleteById, TParametersDeleteById };\n","import type { IDataTreeFolder, IDataTreeNote, TNoteBody } from \"0-shared/types/dataSave\";\n\n/**\n * возвращает массив всех вложенных id внутри Node\n * @param node обьект типа IDataTreeFolder | IDataTreeNote внутри которого нужно собрать id\n */\nfunction getAllIdsInNode(node: IDataTreeFolder | IDataTreeNote) {\n    const allIds = new Set<string>();\n\n    const parser = (node: IDataTreeFolder | IDataTreeNote | TNoteBody) => {\n        for (let prop in node) {\n            if (prop === \"id\") {\n                if (allIds.has(node[prop])) throw new Error(\"Duplicate id in tempData\");\n                allIds.add(node[prop]);\n                continue;\n            }\n            if (prop === \"children\") {\n                for (let item of (node as IDataTreeFolder)[prop]!) {\n                    parser(item);\n                }\n            }\n            if (prop === \"body\") {\n                for (let item of (node as IDataTreeNote)[prop]) {\n                    parser(item);\n                }\n            }\n        }\n    };\n\n    parser(node);\n    return Array.from(allIds);\n}\n\nexport { getAllIdsInNode };\n","import { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport type { IDataTreeRootFolder, TchildrenType, TNoteBody } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeGetNodeById = ReturnType<typeof getNodeById>;\ntype TParametersGetNodeById = Parameters<typeof getNodeById>;\n\n/**\n * ищет ноду по заданному id и возвращает ее\n * @param rootNode обект типа IDataTreeRootFolder | TchildrenType | TNoteBody | undefined\n * @param find_id искомый ID\n * @returns\n */\nfunction getNodeById(rootNode: IDataTreeRootFolder | TchildrenType | TNoteBody | undefined, find_id: string) {\n    const finder = (node: TchildrenType | TNoteBody): TchildrenType | TNoteBody | null => {\n        if (node.id === find_id) {\n            return node;\n        }\n\n        if (isDataTreeFolder(node)) {\n            if (node.children) {\n                for (let child of node.children) {\n                    let result = finder(child);\n                    if (result) return result;\n                }\n            }\n        }\n\n        if (isDataTreeNote(node)) {\n            for (let component of node.body) {\n                if (component.id === find_id) {\n                    return component;\n                }\n            }\n        }\n\n        return null;\n    };\n\n    if (rootNode) {\n        let root = rootNode;\n        return finder(root as TchildrenType | TNoteBody);\n    }\n\n    return null;\n}\n\nexport { getNodeById };\nexport type { TReturnTypeGetNodeById, TParametersGetNodeById };\n","import { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getTableDB } from \"2-features/utils/appIndexedDBFynctions/tableFunctions\";\nimport type { IFindNodeParametres } from \"5-app/GlobalState/toolBarStore\";\nimport type { IDataTreeRootFolder, IDataTreeFolder, IDataTreeNote } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeCloneFiltredTree = ReturnType<typeof cloneFiltredTree>;\ntype TParametersCloneFiltredTree = Parameters<typeof cloneFiltredTree>;\n\n/**\n *  функционал для поиска заметок\n *  клонирование исходного дерева с учетом параметров поиска, ненужные ноды игнорируются для клонирования,\n *  если в ходе фильтрации появляются пустые папки они также игнорируются.\n * @param orig_obj обьект data_tree (содеращий все дерево заметок)\n * @param filtres обьект с параметрами поиска\n * @returns [клонированный обьект, Set всех id папок которые есть в клон.обьекте]\n */\nasync function cloneFiltredTree(\n    orig_obj: IDataTreeRootFolder,\n    filtres: IFindNodeParametres | undefined\n): Promise<[clonedObj: IDataTreeFolder, internalFoldersId: Set<string>]> {\n    let clonedObj = { ...orig_obj, children: [] } as IDataTreeFolder;\n    let internalFoldersId: Set<string> = new Set<string>();\n\n    if (!filtres) return [orig_obj, internalFoldersId];\n\n    clonedObj = (await deepClone(orig_obj, clonedObj, filtres, internalFoldersId)) ?? orig_obj;\n    return [clonedObj, internalFoldersId];\n}\n\n/**\n * непосредственно функция клонирования\n */\nasync function deepClone(\n    origNode: IDataTreeFolder,\n    clonedObj: IDataTreeFolder,\n    filtres: IFindNodeParametres,\n    internalFoldersId: Set<string>\n) {\n    if (clonedObj.id === \"root\") !internalFoldersId.has(clonedObj.id) && internalFoldersId.add(clonedObj.id);\n\n    for (let child of (origNode as IDataTreeFolder)[\"children\"]!) {\n        if (isDataTreeNote(child) && (await checkFilter(child, filtres))) {\n            !internalFoldersId.has(origNode.id) && internalFoldersId.add(origNode.id);\n            const cloneNote = structuredClone(child);\n            clonedObj[\"children\"]!.push(cloneNote);\n            continue;\n        }\n\n        if (isDataTreeFolder(child)) {\n            if (child.children && child.children.length > 0) {\n                const copyChildNode = { ...child, children: [] } as IDataTreeFolder;\n                let innderFolder = await deepClone(child, copyChildNode, filtres, internalFoldersId);\n                if (innderFolder.children && innderFolder.children.length > 0) {\n                    clonedObj[\"children\"]!.push(innderFolder);\n                    !internalFoldersId.has(innderFolder.id) && internalFoldersId.add(innderFolder.id);\n                }\n            }\n        }\n    }\n\n    return clonedObj;\n}\n\n/**\n * ф.ция проверяет соответствует-ли заметка требуемым параметрам поиска\n */\nasync function checkFilter(note: IDataTreeNote, filtres: IFindNodeParametres) {\n    let resultName = false;\n    let resultTags = false;\n    let resultContent = false;\n\n    if (filtres.name !== \"\") {\n        if (note.name.includes(filtres.name)) resultName = true;\n    } else {\n        resultName = true;\n    }\n\n    if (filtres.tags.length > 0) {\n        if (filtres.tags.length > 0 && (!note.tags || (note.tags && note.tags.length === 0))) resultTags = false;\n        if (filtres.tags.length > 0 && note.tags && note.tags.length > 0) {\n            let included: string[] = [];\n            for (let findTag of filtres.tags) {\n                if (note.tags.includes(findTag)) included.push(findTag);\n            }\n            if (included.length === filtres.tags.length) resultTags = true;\n        }\n    } else {\n        resultTags = true;\n    }\n\n    if (filtres.content !== \"\") {\n        for (let component of note.body) {\n            if (component.value.includes(filtres.content)) return true;\n\n            if (component.component == \"link\") {\n                return component.isLabel && component.labelValue.includes(filtres.content);\n            }\n\n            if (component.component == \"code\") {\n                return component.isExpand && component.expandDesc.includes(filtres.content);\n            }\n\n            if (component.component == \"image\") {\n                return !component.isDescHidden && component.desc.includes(filtres.content);\n            }\n\n            // TODO: для поиска по содержимому таблицы придется реальзовать всю логику через промисы, поэтому пока отложим\n            if (component.component == \"table\") {\n                if (component.desc && component.desc.includes(filtres.content)) return true;\n\n                if (component.value !== \"\") {\n                    const tableData = await getTableDB({ key: component.value });\n                    if (tableData && tableData.value) {\n                        const JSONTableData = JSON.stringify(tableData.value);\n                        return JSONTableData.includes(filtres.content);\n                    }\n                }\n            }\n        }\n    } else {\n        resultContent = true;\n    }\n\n    return resultName && resultTags && resultContent;\n}\n\nexport { cloneFiltredTree };\nexport type { TReturnTypeCloneFiltredTree, TParametersCloneFiltredTree };\n","import { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport type { IDataTreeRootFolder, TchildrenType, TNoteBody, IDataTreeFolder, IDataTreeNote } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeGetParentNode = ReturnType<typeof getParentNode>;\ntype TParametersGetParentNode = Parameters<typeof getParentNode>;\n\n/**\n * ищет родителя ноды. Родителем может быть как папка (для других папок или заметок) так и заметка (для компонентов)\n * @param rootNode обект типа IDataTreeRootFolder | TchildrenType | TNoteBody\n * @param nodeId id ноды для которой нужно отыскать родителя\n */\nfunction getParentNode(\n    rootNode: IDataTreeRootFolder | TchildrenType | TNoteBody,\n    nodeId: string\n): IDataTreeNote | IDataTreeFolder | TNoteBody | null | undefined {\n    type TTreeElement = IDataTreeNote | IDataTreeFolder | TNoteBody;\n\n    let parent: IDataTreeNote | IDataTreeFolder | IDataTreeRootFolder | TNoteBody;\n\n    parent = rootNode;\n\n    let result: TTreeElement | null | undefined;\n\n    const finder = (node: TTreeElement): TTreeElement | null | undefined => {\n        if (node.id === nodeId) {\n            if (node.id === parent.id) return undefined;\n            return parent as TTreeElement;\n        }\n\n        if (isDataTreeFolder(node)) {\n            if (node.children) {\n                let saveParent = parent;\n                parent = node;\n                for (let child of node.children) {\n                    let finder_result = finder(child);\n                    if (finder_result === undefined) return null;\n                    if (finder_result) return finder_result;\n                }\n                parent = saveParent;\n            }\n            return null;\n        }\n\n        if (isDataTreeNote(node)) {\n            let saveParent = parent;\n            parent = node;\n            for (let component of node.body) {\n                let finder_result = finder(component);\n                if (finder_result === undefined) return null;\n                if (finder_result) return finder_result;\n            }\n            parent = saveParent;\n        }\n\n        return null;\n    };\n\n    result = finder(parent);\n    return result;\n}\n\nexport { getParentNode };\nexport type { TReturnTypeGetParentNode, TParametersGetParentNode };\n","import {\n    isFunctionData,\n    isDelByIdData,\n    isDelCompInNote,\n    isCloneFiltredTree,\n    isUpdateNodeValue,\n    isUpdNoteComponentsOrder,\n    isUpdateNodeImage,\n    isUpdateNodeTable,\n    isUpdateNodeTableSettings,\n    isUpdateNodeLink,\n    isGetNodeById,\n    isUpdateNoteComponentLinkSettings,\n    isUpdateNoteComponentImageSettings,\n    isUpdateNoteComponentTextSettings,\n    isUpdateNoteComponentListSettings,\n    isUpdateNoteComponentHeaderSettings,\n    isUpdateNoteComponentCodeSettings,\n    isUpdateNodeCompleted,\n    isUpdateNodeName,\n    isAddNodeTo,\n    isNodeMuveTo,\n    isNoteDeleteTag,\n    isNoteAddTag,\n    isProjectDeleteTag,\n    isGetParentNode,\n    isProjectEditeTag,\n} from \"0-shared/utils/typeHelpers\";\nimport { deleteById } from \"2-features/utils/saveDataEditFunctions/deleteById\";\nimport { deleteComponentInNote } from \"2-features/utils/saveDataEditFunctions/deleteComponentInNote\";\nimport { cloneFiltredTree } from \"0-shared/utils/note_find\";\nimport { updateNodeValue } from \"2-features/utils/saveDataEditFunctions/updateNoteValue\";\nimport { updNoteComponentsOrder } from \"2-features/utils/saveDataEditFunctions/updNoteComponentsOrder\";\nimport { updateNodeImage } from \"2-features/utils/saveDataEditFunctions/updateNoteImage\";\nimport { updateNodeTable } from \"2-features/utils/saveDataEditFunctions/updateNodeTable\";\nimport { updateNodeTableSettings } from \"2-features/utils/saveDataEditFunctions/updateNodeTableSettings\";\nimport { updateNodeLink } from \"2-features/utils/saveDataEditFunctions/updateNodeLink\";\nimport { getNodeById } from \"2-features/utils/saveDataParseFunctions/getNodeById\";\nimport { updateNoteComponentLinkSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentLinkSettings\";\nimport { updateNoteComponentImageSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentImageSettings\";\nimport { updateNoteComponentTextSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentTextSettings\";\nimport { updateNoteComponentListSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentListSettings\";\nimport { updateNoteComponentHeaderSettings } from \"2-features/utils/saveDataEditFunctions/updateNoteComponentHeaderSettings\";\nimport { updateNoteComponentCodeSettings } from \"2-features/utils/saveDataEditFunctions/componentCodeSettings\";\nimport { updateNodeCompleted } from \"2-features/utils/saveDataEditFunctions/updateNodeCompleted\";\nimport { updateNodeName } from \"2-features/utils/saveDataEditFunctions/updateNodeName\";\nimport { addNodeTo } from \"2-features/utils/saveDataEditFunctions/addNodeTo\";\nimport { nodeMuveTo } from \"2-features/utils/saveDataEditFunctions/nodeMuveTo\";\nimport { noteDeleteTag } from \"2-features/utils/saveDataEditFunctions/noteDeleteTag\";\nimport { noteAddTag } from \"2-features/utils/saveDataEditFunctions/noteAddTag\";\nimport { projectDeleteTag } from \"2-features/utils/saveDataEditFunctions/projectDeleteTag\";\nimport { getParentNode } from \"2-features/utils/saveDataParseFunctions/getParentNode\";\nimport { projectEditeTag } from \"2-features/utils/saveDataEditFunctions/projectEditeTag\";\nimport type {\n    TMessageDataType,\n    TMessageDelById,\n    TMessageDelCompInNote,\n    TMessageCloneFiltredTreeOnWorker,\n    TMessageUpdateNodeValueOnWorker,\n    TMessageUpdNoteComponentsOrderOnWorker,\n    TMessageUpdateNodeImageOnWorker,\n    TMessageUpdateNodeTableOnWorker,\n    TMessageUpdateNodeTableSettingsOnWorker,\n    TMessageUpdateNodeLinkOnWorker,\n    TMessageGetNodeByIdOnWorker,\n    TMessageUpdateNoteComponentLinkSettingsOnWorker,\n    TMessageUpdateNoteComponentImageSettingsOnWorker,\n    TMessageUpdateNoteComponentTextSettingsOnWorker,\n    TMessageUpdateNoteComponentListSettingsOnWorker,\n    TMessageUpdateNoteComponentHeaderSettingsOnWorker,\n    TMessageUpdateNoteComponentCodeSettingsOnWorker,\n    TMessageUpdateNodeCompletedOnWorker,\n    TMessageUpdateNodeNameOnWorker,\n    TMessageAddNodeToOnWorker,\n    TMessageNodeMuveToOnWorker,\n    TMessageNoteDeleteTagOnWorker,\n    TMessageNoteAddTagOnWorker,\n    TMessageProjectDeleteTagOnWorker,\n    TMessageGetParentNodeOnWorker,\n    TMessageProjectEditeTagOnWorker,\n} from \"./workerTypes\";\n\ntype TTaskRunerTypes =\n    | TMessageDelById\n    | TMessageDelCompInNote\n    | TMessageCloneFiltredTreeOnWorker\n    | TMessageUpdateNodeValueOnWorker\n    | TMessageUpdNoteComponentsOrderOnWorker\n    | TMessageUpdateNodeImageOnWorker\n    | TMessageUpdateNodeTableOnWorker\n    | TMessageUpdateNodeTableSettingsOnWorker\n    | TMessageUpdateNodeLinkOnWorker\n    | TMessageGetNodeByIdOnWorker\n    | TMessageUpdateNoteComponentLinkSettingsOnWorker\n    | TMessageUpdateNoteComponentImageSettingsOnWorker\n    | TMessageUpdateNoteComponentTextSettingsOnWorker\n    | TMessageUpdateNoteComponentListSettingsOnWorker\n    | TMessageUpdateNoteComponentHeaderSettingsOnWorker\n    | TMessageUpdateNoteComponentCodeSettingsOnWorker\n    | TMessageUpdateNodeCompletedOnWorker\n    | TMessageUpdateNodeNameOnWorker\n    | TMessageAddNodeToOnWorker\n    | TMessageNodeMuveToOnWorker\n    | TMessageNoteDeleteTagOnWorker\n    | TMessageNoteAddTagOnWorker\n    | TMessageProjectDeleteTagOnWorker\n    | TMessageGetParentNodeOnWorker\n    | TMessageProjectEditeTagOnWorker;\n\n/**\n * получение данных\n */\n//eslint-disable-next-line\nself.onmessage = (e: MessageEvent) => {\n    const data = e.data;\n    if (!data) return;\n\n    if (isFunctionData(data)) {\n        funcExecutorCase(data);\n        return;\n    }\n\n    if (\n        isUpdateNoteComponentImageSettings(data) ||\n        isUpdateNoteComponentLinkSettings(data) ||\n        isGetNodeById(data) ||\n        isUpdateNodeLink(data) ||\n        isUpdateNodeTableSettings(data) ||\n        isUpdateNodeTable(data) ||\n        isUpdateNodeImage(data) ||\n        isUpdNoteComponentsOrder(data) ||\n        isUpdateNodeValue(data) ||\n        isCloneFiltredTree(data) ||\n        isDelCompInNote(data) ||\n        isDelByIdData(data) ||\n        isUpdateNoteComponentTextSettings(data) ||\n        isUpdateNoteComponentListSettings(data) ||\n        isUpdateNoteComponentHeaderSettings(data) ||\n        isUpdateNoteComponentCodeSettings(data) ||\n        isUpdateNodeCompleted(data) ||\n        isUpdateNodeName(data) ||\n        isAddNodeTo(data) ||\n        isNodeMuveTo(data) ||\n        isNoteDeleteTag(data) ||\n        isNoteAddTag(data) ||\n        isProjectDeleteTag(data) ||\n        isGetParentNode(data) ||\n        isProjectEditeTag(data)\n    ) {\n        taskRuner(data);\n        return;\n    }\n};\n\n/**\n * отправка данных в рантайм\n */\nfunction worker_postMessage(resolve: string = \"\", work_data: any = null) {\n    //eslint-disable-next-line\n    self.postMessage({\n        resolve: resolve,\n        work_data: work_data,\n    });\n}\n\n/**\n * кейс с выполнением функции\n */\nfunction funcExecutorCase({ argument_names = [], argument_values = [], func_data = \"\" }: TMessageDataType) {\n    if (func_data) {\n        worker_postMessage(\"Function executor: started\");\n        func_runer(argument_names, argument_values, func_data);\n    }\n}\n\n/**\n * создание и выполнение полученной функции\n */\nfunction func_runer(argument_names: string[], argument_values: any[], func_data: string) {\n    try {\n        const func = new Function(...argument_names, func_data);\n        const result = func(...argument_values);\n        worker_postMessage(\"Function executor: finished\", result);\n    } catch (e) {\n        worker_postMessage(\"Function executor: error\");\n        console.error(e);\n    }\n}\n\nasync function taskRuner(data: TTaskRunerTypes) {\n    try {\n        worker_postMessage(`${data.type}: started`);\n        console.info(`dedicatedWorker.taskRuner: type '${data.type}'`);\n        let result: any = undefined;\n\n        switch (data.type) {\n            case \"update note component image settings\":\n                result = await updateNoteComponentImageSettings(data);\n                break;\n            case \"clone filtred tree\":\n                result = await cloneFiltredTree(...data.args);\n                break;\n            case \"delete by id\":\n                result = await deleteById(data);\n                break;\n            case \"delete component in note\":\n                result = await deleteComponentInNote(data);\n                break;\n            case \"get node by id\":\n                result = getNodeById(...data.args);\n                break;\n            case \"update Note component link settings\":\n                result = await updateNoteComponentLinkSettings(data);\n                break;\n            case \"update node image\":\n                result = await updateNodeImage(data);\n                break;\n            case \"update node link\":\n                result = await updateNodeLink(data);\n                break;\n            case \"update node table\":\n                result = await updateNodeTable(data);\n                break;\n            case \"update node table settings\":\n                result = await updateNodeTableSettings(data);\n                break;\n            case \"update node value\":\n                result = await updateNodeValue(data);\n                break;\n            case \"update note components order\":\n                result = await updNoteComponentsOrder(data);\n                break;\n            case \"update note component text settings\":\n                result = await updateNoteComponentTextSettings(data);\n                break;\n            case \"update note component list settings\":\n                result = await updateNoteComponentListSettings(data);\n                break;\n            case \"update note component header settings\":\n                result = await updateNoteComponentHeaderSettings(data);\n                break;\n            case \"update note component code settings\":\n                result = await updateNoteComponentCodeSettings(data);\n                break;\n            case \"update node completed\":\n                result = await updateNodeCompleted(data);\n                break;\n            case \"update node name\":\n                result = await updateNodeName(data);\n                break;\n            case \"add node to\":\n                result = await addNodeTo(data);\n                break;\n            case \"node move to\":\n                result = await nodeMuveTo(data);\n                break;\n            case \"note delete tag\":\n                result = await noteDeleteTag(data);\n                break;\n            case \"note add tag\":\n                result = await noteAddTag(data);\n                break;\n            case \"project delete tag\":\n                result = await projectDeleteTag(data);\n                break;\n            case \"get parent node\":\n                result = await getParentNode(...data.args);\n                break;\n            case \"project edite tag\":\n                result = await projectEditeTag(data);\n                break;\n            default:\n                console.error(`dedicatedWorker.taskRuner: task type error, task '${(data as any).type}' unknown`);\n                throw new Error();\n        }\n\n        worker_postMessage(`${data.type}: finished`, result);\n    } catch (e) {\n        worker_postMessage(`${data.type}: error`);\n        console.error(e);\n    }\n}\n","import { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentImageSettings = ReturnType<typeof updateNoteComponentImageSettings>;\ntype TParametersUpdateNoteComponentImageSettings = Parameters<typeof updateNoteComponentImageSettings>;\n\n/**\n * изменяет настройки компонента image в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняются данные\n * @param imageDesc новое описание\n * @param isDescHidden нужноли скрыть описание\n */\nasync function updateNoteComponentImageSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    imageDesc: string;\n    isDescHidden: boolean;\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"image\") {\n                component.desc = data.imageDesc;\n                component.isDescHidden = data.isDescHidden;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentImageSettings };\nexport type { TReturnTypeUpdateNoteComponentImageSettings, TParametersUpdateNoteComponentImageSettings };\n","import type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { delImageDB } from \"../appIndexedDBFynctions/imageFunctions\";\nimport { delTableDB } from \"../appIndexedDBFynctions/tableFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { IdGenerator } from \"0-shared/utils/idGenerator\";\n\ntype TReturnTypeDeleteComponentInNote = ReturnType<typeof deleteComponentInNote>;\ntype TParametersDeleteComponentInNote = Parameters<typeof deleteComponentInNote>;\n\n/**\n * удаление компонента из заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteID id заметки\n * @param componentID id компонента который нужно удалить\n */\nasync function deleteComponentInNote(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteID: string;\n    componentID: string;\n    savedIdGenerator: string[];\n}) {\n    let newIdGenerator = new IdGenerator(new Set(data.savedIdGenerator));\n    let resultBool = false;\n\n    let targetNote = getNodeById(data.rootFolder, data.noteID);\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        targetNote.body = targetNote.body.filter((item) => {\n            if (item.id === data.componentID) {\n                newIdGenerator.deleteId(data.componentID);\n                if (item.component == \"image\") {\n                    delImageDB({ key: item.id });\n                    item.value = \"\";\n                }\n                if (item.component == \"table\") {\n                    delTableDB({ key: item.id });\n                    item.value = \"\";\n                }\n                return false;\n            }\n            return true;\n        });\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool, newIdGenerator: newIdGenerator.getIdsArray() };\n}\n\nexport { deleteComponentInNote };\nexport type { TReturnTypeDeleteComponentInNote, TParametersDeleteComponentInNote };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, TBodyComponentLink } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentLinkSettings = ReturnType<typeof updateNoteComponentLinkSettings>;\ntype TParametersUpdateNoteComponentLinkSettings = Parameters<typeof updateNoteComponentLinkSettings>;\n\n/**\n * изменяет настройки компонента ссылки в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняются данные\n * @param isLabel новое значение isLabel\n * @param isBg новое значение isBg\n * @param labelVal новое значение labelVal\n */\nasync function updateNoteComponentLinkSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    isLabel: TBodyComponentLink[\"isLabel\"];\n    isBg: TBodyComponentLink[\"background\"];\n    labelVal: TBodyComponentLink[\"labelValue\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"link\") {\n                component.background = data.isBg;\n                component.isLabel = data.isLabel;\n                component.labelValue = data.labelVal;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentLinkSettings };\nexport type { TReturnTypeUpdateNoteComponentLinkSettings, TParametersUpdateNoteComponentLinkSettings };\n","import { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { setImageDB } from \"../appIndexedDBFynctions/imageFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeImage = ReturnType<typeof updateNodeImage>;\ntype TParametersUpdateNodeImage = Parameters<typeof updateNodeImage>;\n\n/**\n * изменяет компонент картинки в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param newValue новое значение value\n * @returns\n */\nasync function updateNodeImage(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    newSrc: string;\n    newName: string;\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    // TODO: потом нужно это оптимизировать\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"image\") {\n                component.fileName = data.newName;\n\n                if (data.newSrc === \"\") {\n                    component.value = \"\";\n                    component.desc = \"\";\n                } else {\n                    component.value = component.id;\n                }\n                setImageDB({\n                    value: {\n                        id: data.componentId,\n                        src: data.newSrc,\n                    },\n                    key: component.id,\n                });\n            }\n            break;\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeImage };\nexport type { TReturnTypeUpdateNodeImage, TParametersUpdateNodeImage };\n","import { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport type { IDataTreeRootFolder, TBodyComponentLink } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeLink = ReturnType<typeof updateNodeLink>;\ntype TParametersUpdateNodeLink = Parameters<typeof updateNodeLink>;\n\n/**\n * изменяет компонент ссылки в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param target новое значение target\n * @param value новое значение value\n */\nasync function updateNodeLink(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    target: TBodyComponentLink[\"target\"];\n    value: TBodyComponentLink[\"value\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"link\") {\n                component.target = data.target;\n                component.value = data.value;\n            }\n            break;\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeLink };\nexport type { TReturnTypeUpdateNodeLink, TParametersUpdateNodeLink };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { delTableDB, setTableDB } from \"../appIndexedDBFynctions/tableFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { TTableValue } from \"0-shared/types/dataSave\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeTable = ReturnType<typeof updateNodeTable>;\ntype TParametersUpdateNodeTable = Parameters<typeof updateNodeTable>;\n\n/**\n * изменяет компонент таблицы в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param newValue новое значение TTableValue\n * @returns\n */\nasync function updateNodeTable(data: { rootFolder: IDataTreeRootFolder; noteId: string; componentId: string; newValue: TTableValue | \"\" }) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    // TODO: потом нужно это оптимизировать\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"table\") {\n                if (data.newValue === \"\") {\n                    component.value = \"\";\n                    delTableDB({ key: data.componentId });\n                } else {\n                    component.value = data.componentId;\n                    setTableDB({\n                        value: {\n                            id: data.componentId,\n                            value: data.newValue,\n                        },\n                        key: data.componentId,\n                    });\n                }\n            }\n            break;\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeTable };\nexport type { TReturnTypeUpdateNodeTable, TParametersUpdateNodeTable };\n","import { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport type { TBodyComponentTable, IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeTableSettings = ReturnType<typeof updateNodeTableSettings>;\ntype TParametersUpdateNodeTableSettings = Parameters<typeof updateNodeTableSettings>;\n\n/**\n * изменяет настройки компонента таблицы в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param backlight подцветка строк\n * @param desc описание таблицы\n * @param viewButtons элементы управления в режиме просмотра\n * @returns\n */\nasync function updateNodeTableSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    backlight: TBodyComponentTable[\"backlight\"];\n    desc: TBodyComponentTable[\"desc\"];\n    viewButtons: TBodyComponentTable[\"viewButtons\"];\n    aligin: TBodyComponentTable[\"aligin\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"table\") {\n                component.backlight = data.backlight;\n                component.desc = data.desc;\n                component.viewButtons = data.viewButtons;\n                component.aligin = data.aligin;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeTableSettings };\nexport type { TReturnTypeUpdateNodeTableSettings, TParametersUpdateNodeTableSettings };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeValue = ReturnType<typeof updateNodeValue>;\ntype TParametersUpdateNodeValue = Parameters<typeof updateNodeValue>;\n\n/**\n * изменяет своиство value в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param newValue новое значение value\n * @returns\n */\nasync function updateNodeValue(data: { rootFolder: IDataTreeRootFolder; noteId: string; componentId: string; newValue: string }) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    // TODO: потом нужно это оптимизировать\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            component.value = data.newValue;\n            break;\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeValue };\nexport type { TReturnTypeUpdateNodeValue, TParametersUpdateNodeValue };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { moveElement } from \"0-shared/utils/arrayFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdNoteComponentsOrder = ReturnType<typeof updNoteComponentsOrder>;\ntype TParametersUpdNoteComponentsOrder = Parameters<typeof updNoteComponentsOrder>;\n\n/**\n * меняет порядок компонентов в заметке\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой меняем компоненты местами\n * @param componentDragId id компонента который двигаем\n * @param toComponentDragId id компонента на место которого поставим \"componentDragId\"\n */\nasync function updNoteComponentsOrder(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentDragId: string;\n    toComponentDragId: string;\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        let dragComponentIndex: number | null = null;\n        let toComponentIndex: number | null = null;\n\n        for (let i = 0; i < targetNote.body.length; i++) {\n            if (dragComponentIndex && toComponentIndex) {\n                break;\n            }\n            if (targetNote.body[i].id === data.componentDragId) {\n                dragComponentIndex = i;\n                continue;\n            }\n            if (targetNote.body[i].id === data.toComponentDragId) {\n                toComponentIndex = i;\n                continue;\n            }\n        }\n\n        if (dragComponentIndex !== null && toComponentIndex !== null) {\n            targetNote.body = moveElement(targetNote.body, dragComponentIndex, toComponentIndex);\n        }\n\n        targetNote.lastEditTime = Date.now();\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updNoteComponentsOrder };\nexport type { TReturnTypeUpdNoteComponentsOrder, TParametersUpdNoteComponentsOrder };\n","/**\n * сдвигает все элементы массива та кчтобы fromIndex оказался на позиции toIndex, при этом остальные элементы сдвигаются заполняя освободившееся место\n * @param arr - массив элементов\n * @param fromIndex - индекс который нукжно переместить\n * @param toIndex - индекс куда нужно переменстить fromIndex\n * @returns новый массив\n */\nfunction moveElement(arr: any[], fromIndex: number, toIndex: number): any[] {\n    let copyArr = [...arr];\n    const temp = copyArr[fromIndex];\n\n    if (fromIndex < toIndex) {\n        for (let i = fromIndex; i < toIndex; i++) {\n            copyArr[i] = copyArr[i + 1];\n        }\n    } else {\n        for (let i = fromIndex; i > toIndex; i--) {\n            copyArr[i] = copyArr[i - 1];\n        }\n    }\n\n    copyArr[toIndex] = temp;\n    return copyArr;\n}\n\nexport { moveElement };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, TBodyComponentText } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentTextSettings = ReturnType<typeof updateNoteComponentTextSettings>;\ntype TParametersUpdateNoteComponentTextSettings = Parameters<typeof updateNoteComponentTextSettings>;\n\n/**\n * изменяет настройки компонента текста в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param textBackground значение фона для текста\n * @param textFormat нужноли форматировать текст\n * @param fontValue тип шрифта для текста\n * @param lineBreak автоматический перенос строк\n */\nasync function updateNoteComponentTextSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    textBackground: boolean;\n    textFormat: boolean;\n    fontValue: TBodyComponentText[\"font\"];\n    lineBreak: boolean;\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"text\") {\n                component.background = data.textBackground;\n                component.font = data.fontValue;\n                component.formatting = data.textFormat;\n                component.lineBreak = data.lineBreak;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentTextSettings };\nexport type { TReturnTypeUpdateNoteComponentTextSettings, TParametersUpdateNoteComponentTextSettings };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, TBodyComponentList } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentListSettings = ReturnType<typeof updateNoteComponentListSettings>;\ntype TParametersUpdateNoteComponentListSettings = Parameters<typeof updateNoteComponentListSettings>;\n\n/**\n * изменяет настройки компонента списка в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param listBg значение фона для списка\n * @param isNumeric установить номеруемый тип\n */\nasync function updateNoteComponentListSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    listBg: TBodyComponentList[\"background\"];\n    isNumeric: TBodyComponentList[\"isNumeric\"];\n    aligin: TBodyComponentList[\"textAligin\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"list\") {\n                component.background = data.listBg;\n                component.isNumeric = data.isNumeric;\n                component.textAligin = data.aligin;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentListSettings };\nexport type { TReturnTypeUpdateNoteComponentListSettings, TParametersUpdateNoteComponentListSettings };\n","import { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport type { IDataTreeRootFolder, TBodyComponentHeader } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentHeaderSettings = ReturnType<typeof updateNoteComponentHeaderSettings>;\ntype TParametersUpdateNoteComponentHeaderSettings = Parameters<typeof updateNoteComponentHeaderSettings>;\n\n/**\n * изменяет настройки компонента заголовка в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param textAligin выравнивание текста\n * @param headerSize размер заголовка\n */\nasync function updateNoteComponentHeaderSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    textAligin: TBodyComponentHeader[\"textAligin\"];\n    headerSize: TBodyComponentHeader[\"headerSize\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"header\") {\n                component.headerSize = data.headerSize;\n                component.textAligin = data.textAligin;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentHeaderSettings };\nexport type { TReturnTypeUpdateNoteComponentHeaderSettings, TParametersUpdateNoteComponentHeaderSettings };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, TBodyComponentCode } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNoteComponentCodeSettings = ReturnType<typeof updateNoteComponentCodeSettings>;\ntype TParametersUpdateNoteComponentCodeSettings = Parameters<typeof updateNoteComponentCodeSettings>;\n\n/**\n * изменяет настройки компонента кода в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой редактируем компонент\n * @param componentId id компонента в котором меняется value\n * @param codeTheme цветовая тема кода\n * @param codeLanguage язык кода (для подцветки синтаксиса)\n */\nasync function updateNoteComponentCodeSettings(data: {\n    rootFolder: IDataTreeRootFolder;\n    noteId: string;\n    componentId: string;\n    codeTheme: TBodyComponentCode[\"codeTheme\"];\n    codeLanguage: TBodyComponentCode[\"language\"];\n    isExpand: TBodyComponentCode[\"isExpand\"];\n    expandDesc: TBodyComponentCode[\"expandDesc\"];\n}) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        for (let component of targetNote.body) {\n            if (component.id !== data.componentId) continue;\n            if (component.component === \"code\") {\n                component.codeTheme = data.codeTheme;\n                component.language = data.codeLanguage;\n                component.isExpand = data.isExpand;\n                component.expandDesc = data.expandDesc;\n\n                targetNote.lastEditTime = Date.now();\n                resultBool = true;\n                await setDataTreeDB({ value: data.rootFolder });\n                break;\n            }\n        }\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNoteComponentCodeSettings };\nexport type { TReturnTypeUpdateNoteComponentCodeSettings, TParametersUpdateNoteComponentCodeSettings };\n","import { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeCompleted = ReturnType<typeof updateNodeCompleted>;\ntype TParametersUpdateNodeCompleted = Parameters<typeof updateNodeCompleted>;\n\n/**\n * изменяет своиство completed в обьекте заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param noteId id заметки в которой нужно поменять completed\n * @param newValue новое значение completed\n * @returns\n */\nasync function updateNodeCompleted(data: { rootFolder: IDataTreeRootFolder; noteId: string; newValue: boolean }) {\n    let targetNote = getNodeById(data.rootFolder, data.noteId);\n    let resultBool = false;\n\n    if (targetNote && isDataTreeNote(targetNote)) {\n        if (targetNote.completed !== data.newValue) {\n            targetNote.completed = data.newValue;\n            resultBool = true;\n            targetNote.lastEditTime = Date.now();\n            await setDataTreeDB({ value: data.rootFolder });\n        }\n        resultBool = true;\n    }\n\n    return { targetNote, resultBool };\n}\n\nexport { updateNodeCompleted };\nexport type { TParametersUpdateNodeCompleted, TReturnTypeUpdateNodeCompleted };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote, isDataTreeFolder } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeUpdateNodeName = ReturnType<typeof updateNodeName>;\ntype TParametersUpdateNodeName = Parameters<typeof updateNodeName>;\n\n/**\n * изменяет своиство Name в ноде дерева\n * @param rootFolder обьект IDataTreeRootFolder\n * @param target_id id компонента в котором нужно поменять Name\n * @param newName новое значение Name\n */\nasync function updateNodeName(data: { rootFolder: IDataTreeRootFolder; target_id: string; newName: string }) {\n    let targetNode = getNodeById(data.rootFolder, data.target_id);\n    let resultBool = false;\n\n    if ((targetNode && isDataTreeFolder(targetNode)) || isDataTreeNote(targetNode)) {\n        targetNode.name = data.newName;\n        resultBool = true;\n        if (isDataTreeNote(targetNode)) {\n            targetNode.lastEditTime = Date.now();\n        }\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { targetNode, resultBool };\n}\n\nexport { updateNodeName };\nexport type { TReturnTypeUpdateNodeName, TParametersUpdateNodeName };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeFolder, isDataTreeNote, isDataNoteBody } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { DataFolder } from \"0-shared/utils/classes/saveDataFolder\";\nimport type { DataNote } from \"0-shared/utils/classes/saveDataNote\";\nimport type { IDataTreeRootFolder, TchildrenType, TNoteBody, IDataTreeFolder, IDataTreeNote } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeAddNodeTo = ReturnType<typeof addNodeTo>;\ntype TParametersAddNodeTo = Parameters<typeof addNodeTo>;\n\n/**\n * Добавляет ноду в дерево\n * @param rootFolder - обьект сохранения IDataTreeRootFolder\n * @param insertToId - id ноды в которую нужно добавить\n * @param newNode - обьект новой ноды (классы из 0-shared/utils/saveData... .ts)\n */\nasync function addNodeTo(data: {\n    rootFolder: IDataTreeRootFolder;\n    insertToId: string;\n    newNode: TchildrenType | TNoteBody | DataNote | DataFolder;\n}): Promise<{ newNode: null | IDataTreeFolder | IDataTreeNote | TNoteBody; resultBool: boolean }> {\n    let targetNode = getNodeById(data.rootFolder, data.insertToId);\n    let resultBool = false;\n\n    if (!targetNode) return { newNode: null, resultBool };\n\n    // в папку мы можем добавить другую папку или заметку\n    if (isDataTreeFolder(targetNode) && (isDataTreeFolder(data.newNode) || isDataTreeNote(data.newNode))) {\n        if (!targetNode.children) targetNode.children = [];\n        targetNode.children.push(data.newNode);\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n        return { newNode: data.newNode, resultBool };\n    }\n\n    // в заметку мы можем добавить компонент\n    if (isDataTreeNote(targetNode) && isDataNoteBody(data.newNode)) {\n        targetNode.body.push(data.newNode);\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n        return { newNode: data.newNode, resultBool };\n    }\n\n    return { newNode: null, resultBool };\n}\n\nexport { addNodeTo };\nexport type { TReturnTypeAddNodeTo, TParametersAddNodeTo };\n","import { isDataTreeFolder, isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { getParentNode } from \"../saveDataParseFunctions/getParentNode\";\nimport { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport type { IDataTreeRootFolder, IDataTreeFolder, IDataTreeNote, TNoteBody } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeNodeMuveTo = ReturnType<typeof nodeMuveTo>;\ntype TParametersNodeMuveTo = Parameters<typeof nodeMuveTo>;\n\n/**\n * перемещает заметку или папку в другую папку\n * @param rootFolder - обьект сохранения IDataTreeRootFolder\n * @param muvedNodeID - id ноды которую перемещаем\n * @param muveToID - id ноды куда перемещаем\n */\nasync function nodeMuveTo(data: {\n    rootFolder: IDataTreeRootFolder;\n    muvedNodeID: string;\n    muveToID: string;\n}): Promise<{ muvedNode: IDataTreeFolder | IDataTreeNote | TNoteBody | null; resultBool: boolean }> {\n    let muvedNode = getNodeById(data.rootFolder, data.muvedNodeID);\n    let muvedNodeParent = muvedNode && getParentNode(data.rootFolder, muvedNode.id);\n    let moveToNode = getNodeById(data.rootFolder, data.muveToID);\n    let resultBool = false;\n\n    if (!muvedNode || !muvedNodeParent || !moveToNode) return { muvedNode: null, resultBool };\n    if (muvedNode.id === \"root\") return { muvedNode: muvedNode, resultBool };\n    if (getNodeById(muvedNode, moveToNode.id)) return { muvedNode: muvedNode, resultBool }; // чтобы нельзя было переместить папку в ее дочернюю папку\n    if (muvedNodeParent.id === moveToNode.id) return { muvedNode, resultBool }; // если, откуда = куда перемещаем то ничего не делаем\n    if (moveToNode.id === data.muvedNodeID) return { muvedNode, resultBool }; // чтобы нельзя было перемещать элементы самих в себя\n\n    // убераем muvedNode из дочерних элементов muvedNodeParent\n    if (isDataTreeFolder(muvedNodeParent)) {\n        muvedNodeParent.children = muvedNodeParent.children!.filter((element) => {\n            if (element.id === muvedNode!.id) return false;\n            return true;\n        });\n    }\n\n    if (isDataTreeFolder(moveToNode)) {\n        if (!isDataTreeFolder(muvedNode) && !isDataTreeNote(muvedNode)) return { muvedNode: null, resultBool };\n        if (!moveToNode.children) moveToNode.children = [];\n        moveToNode.children.push(muvedNode);\n        resultBool = true;\n        await setDataTreeDB({ value: data.rootFolder });\n        return { muvedNode, resultBool };\n    }\n\n    return { muvedNode: null, resultBool };\n}\n\nexport { nodeMuveTo };\nexport type { TReturnTypeNodeMuveTo, TParametersNodeMuveTo };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, IGlobalTag } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeNoteDeleteTag = ReturnType<typeof noteDeleteTag>;\ntype TParametersNoteDeleteTag = Parameters<typeof noteDeleteTag>;\n\n/**\n * удаляет тег у заметки\n * @param rootFolder обьект IDataTreeRootFolder\n * @param targetNoteID id заметки в которой удаляем\n * @param tag обьект тега который нужно убрать\n */\nasync function noteDeleteTag(data: { rootFolder: IDataTreeRootFolder; targetNoteID: string; tag: IGlobalTag }) {\n    let targetNote = getNodeById(data.rootFolder, data.targetNoteID);\n    let resultBool = false;\n\n    if (!targetNote) return { targetNote: null, resultBool };\n    if (!isDataTreeNote(targetNote)) return { targetNote: null, resultBool };\n    if (!(\"tags\" in targetNote)) return { targetNote: null, resultBool };\n\n    targetNote.tags = targetNote.tags!.filter((tagName) => {\n        if (tagName === data.tag.tag_name) return false;\n        return true;\n    });\n\n    targetNote.lastEditTime = Date.now();\n    resultBool = true;\n    await setDataTreeDB({ value: data.rootFolder });\n\n    return { targetNote, resultBool };\n}\n\nexport { noteDeleteTag };\nexport type { TReturnTypeNoteDeleteTag, TParametersNoteDeleteTag };\n","import { getNodeById } from \"../saveDataParseFunctions/getNodeById\";\nimport { getGlobalTagsDB } from \"../appIndexedDBFynctions/globalTagsFunctions\";\nimport { isDataTreeNote } from \"0-shared/utils/typeHelpers\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeNoteAddTag = ReturnType<typeof noteAddTag>;\ntype TParametersNoteAddTag = Parameters<typeof noteAddTag>;\n\n/**\n * добавляет тег в заметку\n * @param rootFolder обьект IDataTreeRootFolder\n * @param targetNoteID id заметки в которую добавляем\n * @param tag имена тегов которые нужно добавить\n */\nasync function noteAddTag(data: { rootFolder: IDataTreeRootFolder; targetNoteID: string; tag: string | string[] }) {\n    let targetNote = getNodeById(data.rootFolder, data.targetNoteID);\n    const allTags = await getGlobalTagsDB();\n    let prepareTags: string[] = [];\n    let resultBool = false;\n\n    if (!allTags) return { targetNote: null, resultBool };\n\n    if (Array.isArray(data.tag) && data.tag.length > 0) {\n        for (let tagItem of data.tag) {\n            if (!(tagItem in allTags)) return { targetNote: null, resultBool };\n        }\n        prepareTags = [...data.tag];\n    }\n\n    if (typeof data.tag === \"string\" && data.tag !== \"\") {\n        if (!(data.tag in allTags)) {\n            return { targetNote: null, resultBool };\n        }\n        prepareTags.push(data.tag);\n    }\n\n    if (!targetNote) return { targetNote: null, resultBool };\n    if (!isDataTreeNote(targetNote)) return { targetNote: null, resultBool };\n\n    if (!(\"tags\" in targetNote)) {\n        targetNote.tags = [];\n    }\n\n    targetNote.tags = targetNote.tags!.concat(prepareTags);\n    targetNote.lastEditTime = Date.now();\n\n    resultBool = true;\n    await setDataTreeDB({ value: data.rootFolder });\n\n    return { targetNote, resultBool };\n}\n\nexport { noteAddTag };\nexport type { TReturnTypeNoteAddTag, TParametersNoteAddTag };\n","import { getAllNotes } from \"../saveDataParse\";\nimport { setGlobalTagsDB } from \"../appIndexedDBFynctions/globalTagsFunctions\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport type { IDataTreeRootFolder, IAllTags } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeProjectDeleteTag = ReturnType<typeof projectDeleteTag>;\ntype TParametersProjectDeleteTag = Parameters<typeof projectDeleteTag>;\n\n/**\n * удаляет тег из проекта\n * @param tagData обьект\n * @param rootFolder обьект IDataTreeRootFolder\n * @param tagName - имя тега который нужно удалить\n */\nasync function projectDeleteTag(data: { tagData: IAllTags; rootFolder: IDataTreeRootFolder; tagName: string }) {\n    let resultBool = false;\n\n    if (data.tagName in data.tagData) {\n        delete data.tagData[data.tagName];\n        const allNotes = getAllNotes(data.rootFolder);\n\n        for (let note of allNotes) {\n            if (!note.tags) continue;\n            note.tags = note.tags.filter((tag) => {\n                if (tag === data.tagName) return false;\n                return true;\n            });\n        }\n\n        // удалить этот тег из всех заметок\n        resultBool = true;\n        await setGlobalTagsDB({ value: data.tagData });\n        await setDataTreeDB({ value: data.rootFolder });\n    }\n\n    return { tagName: data.tagName, resultBool };\n}\n\nexport { projectDeleteTag };\nexport type { TReturnTypeProjectDeleteTag, TParametersProjectDeleteTag };\n","import { getAllNotes } from \"../saveDataParse\";\nimport { DataTag } from \"0-shared/utils/classes/saveDataTag\";\nimport { setDataTreeDB } from \"../appIndexedDBFynctions/dataTreeDb\";\nimport { setGlobalTagsDB } from \"../appIndexedDBFynctions/globalTagsFunctions\";\nimport type { IAllTags, IDataTreeRootFolder, TTagColors } from \"0-shared/types/dataSave\";\n\ntype TReturnTypeProjectEditeTag = ReturnType<typeof projectEditeTag>;\ntype TParametersProjectEditeTag = Parameters<typeof projectEditeTag>;\n\n/**\n * изменяет тег во всем проекте\n * @param tagData обьект\n * @param rootFolder обьект IDataTreeRootFolder\n * @param oldTagName - старое имя тега\n * @param newTagName - новое имя тега\n * @param newTagColor - новый цвет тега\n */\nasync function projectEditeTag(data: {\n    tagData: IAllTags;\n    rootFolder: IDataTreeRootFolder;\n    oldTagName: string;\n    newTagName: string;\n    newTagColor: TTagColors;\n}) {\n    // так как теги в db хранятся в обьекте по (ключу = имя тега), если имя изменилось то и ключ должен изменится\n    // TODO: возможно в будующем добавлю тегам id и в качестве ключа к тегу будет его id, это серьезно упростит работу с изменением тегов, + положительно скажется на визуальном отображаении. (речь идет о том как рендерится список с key в react ), ведь key равен имяни тега а значит и ключу в db\n    let resultBool = false;\n\n    if (data.oldTagName !== data.newTagName) {\n        if (!(data.newTagName in data.tagData)) {\n            delete data.tagData[data.oldTagName];\n            data.tagData[data.newTagName] = new DataTag(data.newTagName, data.newTagColor);\n            const allNotes = getAllNotes(data.rootFolder);\n\n            for (let note of allNotes) {\n                if (!note.tags) continue;\n                const indexTagOldName = note.tags.indexOf(data.oldTagName);\n                if (indexTagOldName !== -1) {\n                    note.tags[indexTagOldName] = data.newTagName;\n                }\n            }\n            resultBool = true;\n            await setDataTreeDB({ value: data.rootFolder });\n        }\n    } else {\n        resultBool = true;\n        data.tagData[data.oldTagName].color = data.newTagColor;\n    }\n\n    await setGlobalTagsDB({ value: data.tagData });\n\n    return { newTagName: data.newTagName, resultBool };\n}\n\nexport { projectEditeTag };\nexport type { TReturnTypeProjectEditeTag, TParametersProjectEditeTag };\n"],"names":["DataTag","constructor","name","color","tag_name","this","Object","setPrototypeOf","IdGenerator","cache","_cache","Set","generateId","generator","result","i","_charMap","charAt","Math","floor","random","length","newId","has","add","console","log","concat","deleteId","id","delete","getIdsArray","Array","from","Proxy","instatnceIdGenerator","undefined","set","target","prop","newValue","receiver","isDWorkerScope","error","Error","window","dispatchEvent","CustomEvent","group","groupEnd","Reflect","self","toString","isDataTreeNote","node","type","isDataTreeFolder","isDataNoteBody","isFunctionData","value","isArray","argument_names","argument_values","isDelByIdData","rootNode","target_id","savedIdGenerator","isDelCompInNote","rootFolder","componentID","isCloneFiltredTree","orig_obj","isUpdateNodeValue","noteId","componentId","isUpdNoteComponentsOrder","componentDragId","toComponentDragId","isUpdateNodeImage","newName","newSrc","isUpdateNodeTable","headers","rows","isTableValue","isUpdateNodeTableSettings","backlight","desc","viewButtons","aligin","isUpdateNodeLink","isGetNodeById","args","isUpdateNoteComponentLinkSettings","isLabel","isBg","labelVal","isUpdateNoteComponentImageSettings","imageDesc","isDescHidden","isUpdateNoteComponentTextSettings","textBackground","textFormat","fontValue","lineBreak","isUpdateNoteComponentListSettings","listBg","isNumeric","isUpdateNoteComponentHeaderSettings","textAligin","headerSize","isUpdateNoteComponentCodeSettings","codeTheme","codeLanguage","isExpand","expandDesc","isUpdateNodeCompleted","isUpdateNodeName","isAddNodeTo","insertToId","newNode","isNodeMuveTo","muvedNodeID","muveToID","isNoteDeleteTag","targetNoteID","isTGlobalTag","tag","isNoteAddTag","isProjectDeleteTag","tagName","tagData","isGetParentNode","isProjectEditeTag","oldTagName","newTagName","newTagColor","DB_NAME","DB_VERSION","TEMP_DATA_KEY","def_onError","e","warn","def_onComplete","dispatchEventIndexedDBTreeUpdate","postMessage","dispatchEventIndexedDBTagsUpdate","dispatchEventIndexedDBImagesUpdate","dispatchEventIndexedDBTableUpdate","async","setDataTreeDB","_ref","onComplete","onError","callback","tx","openIndexedDB","transaction","onerror","oncomplete","store","put","done","setGlobalTagsDB","getGlobalTagsDB","arguments","get","delImageDB","key","keyItem","setImageDB","_ref2","getKey","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","transactionDoneMap","WeakMap","transformCache","reverseTransformCache","idbProxyTraps","IDBTransaction","objectStoreNames","objectStore","wrap","replaceTraps","wrapFunction","func","IDBCursor","prototype","advance","continue","continuePrimaryKey","includes","_len","_key","apply","unwrap","request","_len2","_key2","transformCachableValue","Promise","resolve","reject","unlisten","removeEventListener","complete","DOMException","addEventListener","cacheDonePromiseForTransaction","IDBDatabase","IDBObjectStore","IDBIndex","IDBRequest","promise","success","promisifyRequest","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","storeName","_len3","_key3","index","shift","all","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","isIteratorProp","Symbol","asyncIterator","db","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","then","catch","openDB","createObjectStore","keyPath","currentVersion","blockedVersion","setTableDB","getTableDB","delTableDB","_ref3","getAllNotes","data","allNotes","parser","children","item","push","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","o","defineProperty","enumerable","obj","hasOwnProperty","call","deleteById","parent","deletedNode","resultBool","newIdGenerator","finder","filter","child","innerIds","allIds","getAllIdsInNode","map","temp","getNodeById","find_id","component","body","cloneFiltredTree","filtres","_await$deepClone","clonedObj","internalFoldersId","deepClone","origNode","checkFilter","cloneNote","structuredClone","copyChildNode","innderFolder","note","resultName","resultTags","resultContent","tags","included","findTag","content","labelValue","tableData","JSON","stringify","getParentNode","nodeId","saveParent","finder_result","worker_postMessage","work_data","onmessage","func_data","Function","func_runer","funcExecutorCase","info","targetNote","lastEditTime","Date","now","updateNoteComponentImageSettings","noteID","deleteComponentInNote","background","updateNoteComponentLinkSettings","fileName","src","updateNodeImage","updateNodeLink","updateNodeTable","updateNodeTableSettings","updateNodeValue","dragComponentIndex","toComponentIndex","arr","fromIndex","toIndex","copyArr","moveElement","updNoteComponentsOrder","font","formatting","updateNoteComponentTextSettings","updateNoteComponentListSettings","updateNoteComponentHeaderSettings","language","updateNoteComponentCodeSettings","completed","updateNodeCompleted","targetNode","updateNodeName","addNodeTo","muvedNode","muvedNodeParent","moveToNode","element","nodeMuveTo","noteDeleteTag","allTags","prepareTags","tagItem","noteAddTag","projectDeleteTag","indexTagOldName","indexOf","projectEditeTag","taskRuner"],"sourceRoot":""}